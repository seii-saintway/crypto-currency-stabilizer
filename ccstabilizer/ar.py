# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/main-ar.ipynb (unless otherwise specified).

__all__ = ['TEST_RATIO', 'NOTIFY_RATE', 'BACKUP_RATE', 'CRYPTO_SYMBOL', 'FIAT_SYMBOL', 'MAX_USED_FIAT_MONEY_LIMIT']

# Cell
TEST_RATIO = 1

# Cell
NOTIFY_RATE = 60 * 8
BACKUP_RATE = 1

# Cell
from decimal import Decimal

CRYPTO_SYMBOL = 'AR'
FIAT_SYMBOL = 'USDT'
MAX_USED_FIAT_MONEY_LIMIT = Decimal('1000')

# Internal Cell
from ccstabilizer import Fetcher
from ccstabilizer import Notifier
from ccstabilizer import Trader
from ccstabilizer import Status

# Internal Cell
fetcher = Fetcher()
notifier = Notifier('Launcher')

# notifier.send_slack(
#     f'{CRYPTO_SYMBOL}-{FIAT_SYMBOL} Detecting started\n', 'Power by https://jhub.name/', 'good'
# )

symbol_in_mxc = f'{CRYPTO_SYMBOL}_{FIAT_SYMBOL}'
crypto_info = {}
while True:
    crypto_info = fetcher.get_trading_spec(symbol_in_mxc)
    if crypto_info.get('symbol', '') == symbol_in_mxc and crypto_info.get('limited', False) == True:
        break
    else:
        time.sleep(Trader.SAMPLE_INTERVAL)

notifier.send_slack(
    f'{CRYPTO_SYMBOL}-{FIAT_SYMBOL} detected\n', 'Power by https://jhub.name/', 'good'
)

status = Status(
    robot_name = f'{CRYPTO_SYMBOL} Robot',
    crypto_symbol = CRYPTO_SYMBOL,
    fiat_symbol = FIAT_SYMBOL,
    max_used_fiat_money_limit = MAX_USED_FIAT_MONEY_LIMIT,
    **crypto_info
)
status.read()

# Internal Cell
from ccstabilizer import BookKeeper
from ccstabilizer import Trader

# Internal Cell
import time


with BookKeeper(status) as bookkeeper:

#     from unittest.mock import Mock
#     bookkeeper.prv.order = Mock()

    trader = Trader(
        status = status,
        gainable_unit_cc_sold_ratio = Decimal('0.236'),
        lossable_unit_cc_bought_ratio = Decimal('0.786'),
        min_trade_fiat_price = Decimal('0'),
        max_trade_fiat_price = Decimal('Infinity')
    )
    notifier = Notifier(status.crypto_symbol)

    notifier.send_slack(
        f'{status.robot_name} launched\n' f'{status.get_robot_title()}', 'Power by https://jhub.name/', 'good'
    )

    while __name__ == '__main__':

        cooling_interval, trade_type, unit_amount = trader.check_and_trade()

        bookkeeper.fsh.write(f'{status}\n')

#         new_status = bookkeeper.estimate_functions.get(trade_type, lambda unit_amount: status)(unit_amount)
        new_status = bookkeeper.estimate_status()

        if new_status is not status:

            status.update(new_status)

            bookkeeper.fth.write(f'{status}\n')
            status.write()

            notifier.send_slack(
                f'{bookkeeper.last_transaction} => {status.get_robot_title()}',
                'Power by https://jhub.name/', 'good' if status.total_gained_fiat_money >= 0 else 'danger'
            )

            notifier.send_slack(
                f'{status} => Support level is {trader.min_unit_cc_trade_fiat_money} {status.fiat_symbol}.',
                'Power by https://jhub.name/', 'good' if status.get_total_gain_fiat_money() >= 0 else 'danger'
            )

#             if status.bought_unit_amount == 0:
#                 break

            if status.total_gained_fiat_money < -Trader.MAX_LOST_JPY:
                break

        else:

            if status.sample_number % Trader.TRADE_RATE == 0:
                bookkeeper.fth.write(f'{status}\n')

            if status.sample_number % BACKUP_RATE == 0:
                status.write()

            if status.sample_number % NOTIFY_RATE == 0:
                notifier.send_slack(
                    f'{status} => Support level is {trader.min_unit_cc_trade_fiat_money} {status.fiat_symbol}.',
                    'Power by https://jhub.name/', 'good' if status.get_total_gain_fiat_money() > 0 else 'danger'
                )

        status.sample_number += 1
        time.sleep(cooling_interval / TEST_RATIO)

    notifier.send_slack(
        f'{status.robot_name} terminated\n' f'{status.get_robot_title()}', 'Power by https://jhub.name/', 'good'
    )