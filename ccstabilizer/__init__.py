# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/22_bookkeeper.ipynb (unless otherwise specified).

__all__ = ['Exchange', 'Binance', 'BinanceAPI', 'Bitbank', 'MXC', 'MXCAPI', 'MXC', 'MXCAPI', 'Status', 'Fetcher',
           'Portfolio', 'BookKeeper', 'Trader', 'Notifier']

# Cell
class Exchange(object):

    def __init__(self):
        self.trading_specifications = {}

    def get_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.trading_specifications.get((crypto_symbol, fiat_symbol), {})

    def get_portfolio(self):
        raise NotImplementedError

    def get_price(self, crypto_symbol, fiat_symbol):
        raise NotImplementedError

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        raise NotImplementedError

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        raise NotImplementedError

# Cell
from decimal import Decimal


class Binance(Exchange):

    def __init__(self):
        super().__init__()
        self.binance = BinanceAPI(os.environ['BINANCE_API_KEY'], os.environ['BINANCE_API_SECRET'])
        for symbol_info in self.binance.exchangeInfo().get('symbols', []):
            symbol = symbol_info.get('symbol', '')
            trading_spec = {}
            for binance_filter in symbol_info.get('filters', []):
                if binance_filter.get('filterType', '') == 'LOT_SIZE':
                    trading_spec['min_trade_unit'] = Decimal(binance_filter.get('stepSize', '0.0001'))
                    break
            for binance_filter in symbol_info.get('filters', []):
                if binance_filter.get('filterType', '') == 'MIN_NOTIONAL':
                    trading_spec['min_trade_fiat_money_limit'] = Decimal(binance_filter.get('minNotional', '0'))
                    break
            trading_spec['fee_rate'] = Decimal('0.001')
            if 'permissions' in symbol_info:
                trading_spec['liquid'] = 'SPOT' in symbol_info.get('permissions', [])
            self.trading_specifications[symbol] = trading_spec

    def get_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.trading_specifications.get(f'{crypto_symbol}{fiat_symbol}', {})

    def get_portfolio(self):
        return {
            asset.get('asset', ''): Decimal(asset.get('free', '0')) for asset in self.binance.account().get('balances', [])
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        avg_price = self.binance.avgPrice(symbol=f'{crypto_symbol}{fiat_symbol}')
        if 'price' in avg_price:
            self.get_trading_specification(crypto_symbol, fiat_symbol)['average_fiat_price'] = Decimal(avg_price.get('price', '0'))
        now_ticker = self.binance.tickerBookTicker(symbol=f'{crypto_symbol}{fiat_symbol}')
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('askPrice', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('bidPrice', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee / (1 - fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee=None):
        if amount <= 0:
            raise Exception('Binance::buy  amount <= 0')
        self.binance.createOrder(
            symbol=f'{crypto_symbol}{fiat_symbol}', side='BUY', type='MARKET', quantity=str(amount), recvWindow=5000
        )

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee=None):
        if amount <= 0:
            raise Exception('Binance::sell  amount <= 0')
        self.binance.createOrder(
            symbol=f'{crypto_symbol}{fiat_symbol}', side='SELL', type='MARKET', quantity=str(amount), recvWindow=5000
        )

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money

    def is_trade_fiat_money_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee=None):
        # Just for Binance
        average_fiat_price = self.get_trading_specification(crypto_symbol, fiat_symbol).get('average_fiat_price', 0)
        return average_fiat_price * amount >= self.get_trading_specification(crypto_symbol, fiat_symbol).get('min_trade_fiat_money_limit', 0)

# Cell
# Credits to @Bablofil https://github.com/Bablofil/binance-api
import contextlib
import time
import json
import urllib
import hmac, hashlib
import requests

from urllib.parse import urlparse, urlencode
from urllib.request import Request, urlopen

class BinanceAPI(object):

    methods = {
            #  Public methods
            'ping':             {'url': 'ping', 'method': 'GET', 'private': False},
            'time':             {'url': 'time', 'method': 'GET', 'private': False},
            'exchangeInfo':     {'url': 'exchangeInfo', 'method': 'GET', 'private': False},
            'depth':            {'url': 'depth', 'method': 'GET', 'private': False},
            'trades':           {'url': 'trades', 'method': 'GET', 'private': False},
            'historicalTrades': {'url': 'historicalTrades', 'method': 'GET', 'private': False},
            'aggTrades':        {'url': 'aggTrades', 'method': 'GET', 'private': False},
            'klines':           {'url': 'klines', 'method': 'GET', 'private': False},
            'avgPrice':         {'url': 'avgPrice', 'method': 'GET', 'private': False},
            'ticker24hr':       {'url': 'ticker/24hr', 'method': 'GET', 'private': False},
            'tickerPrice':      {'url': 'ticker/price', 'method': 'GET', 'private': False},
            'tickerBookTicker': {'url': 'ticker/bookTicker', 'method': 'GET', 'private': False},
            #  Private methods
            'createOrder':      {'url': 'order', 'method': 'POST', 'private': True},
            'testOrder':        {'url': 'test', 'method': 'POST', 'private': True},
            'orderInfo':        {'url': 'order', 'method': 'GET', 'private': True},
            'cancelOrder':      {'url': 'order', 'method': 'DELETE', 'private': True},
            'openOrders':       {'url': 'openOrders', 'method': 'GET', 'private': True},
            'allOrders':        {'url': 'allOrders', 'method': 'GET', 'private': True},
            'account':          {'url': 'account', 'method': 'GET', 'private': True},
            'myTrades':         {'url': 'myTrades', 'method': 'GET', 'private': True},
    }

    RETRY_INTERVAL = 60

    def __init__(self, API_KEY, API_SECRET):
        self.API_KEY = API_KEY
        self.API_SECRET = bytearray(API_SECRET, encoding='utf-8')
        self.shift_seconds = 0

    def __getattr__(self, name):
        def wrapper(*args, **kwargs):
            kwargs.update(command=name)

            while True:
                try:
                    return self.call_api(**kwargs)
                except Exception as e:
                    print(e)
                    raise
                    time.sleep(type(self).RETRY_INTERVAL)

        return wrapper

    def set_shift_seconds(self, seconds):
        self.shift_seconds = seconds

    def call_api(self, **kwargs):

        command = kwargs.pop('command')
        api_url = 'https://api.binance.com/api/v3/' + self.methods[command]['url']

        payload = kwargs
        headers = {}

        payload_str = urllib.parse.urlencode(payload)
        if self.methods[command]['private']:
            payload.update({'timestamp': int(time.time() + self.shift_seconds - 1) * 1000})
            payload_str = urllib.parse.urlencode(payload).encode('utf-8')
            sign = hmac.new(
                key=self.API_SECRET,
                msg=payload_str,
                digestmod=hashlib.sha256
            ).hexdigest()

            payload_str = payload_str.decode("utf-8") + "&signature="+str(sign)
            headers = {"X-MBX-APIKEY": self.API_KEY}

        if self.methods[command]['method'] == 'GET':
            api_url += '?' + payload_str

        with contextlib.closing(
            requests.request(
                method=self.methods[command]['method'], url=api_url, headers=headers,
                data='' if self.methods[command]['method'] == 'GET' else payload_str
            )
        ) as response:
            response_json = response.json()
            if 'code' in response_json:
#                 {"code":-1021,"msg":"Timestamp for this request is outside of the recvWindow."}
                raise Exception(response_json.get('msg', ''))
            return response_json

# Cell
import contextlib, requests
from decimal import Decimal

import python_bitbankcc


class Bitbank(Exchange):

    def __init__(self):
        super().__init__()
        self.pub = python_bitbankcc.public()
        self.prv = python_bitbankcc.private(
            os.environ['BITBANK_API_KEY'],
            os.environ['BITBANK_API_SECRET']
        )
        self.update_trading_specifications()

    def update_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.update_trading_specifications().get((crypto_symbol, fiat_symbol), {})

    def update_trading_specifications(self):
        with contextlib.closing(requests.get('https://api.bitbank.cc/v1/spot/status')) as response:
            specs = response.json().get('data', {}).get('statuses', [])
        for spec in specs:
            crypto_symbol, fiat_symbol = spec.get('pair', '_').split('_')
            crypto_symbol, fiat_symbol = crypto_symbol.upper(), fiat_symbol.upper()
            trading_spec = self.trading_specifications.setdefault((crypto_symbol, fiat_symbol), {})
            if 'min_amount' in spec:
                trading_spec['min_trade_unit'] = Decimal(spec.get('min_amount', '0.0001'))
        with contextlib.closing(requests.get('https://api.bitbank.cc/v1/spot/pairs')) as response:
            specs = response.json().get('data', {}).get('pairs', [])
        for spec in specs:
            crypto_symbol, fiat_symbol = spec.get('name', '_').split('_')
            crypto_symbol, fiat_symbol = crypto_symbol.upper(), fiat_symbol.upper()
            trading_spec = self.trading_specifications.setdefault((crypto_symbol, fiat_symbol), {})
            if 'taker_fee_rate_quote' in spec:
                trading_spec['fee_rate'] = Decimal(spec.get('taker_fee_rate_quote', '0.0012'))
            if 'is_enabled' in spec:
                trading_spec['liquid'] = spec.get('is_enabled', False)
        return self.trading_specifications

    def get_portfolio(self):
        return {
            asset.get('asset', '').upper(): Decimal(asset.get('free_amount', '0')) for asset in self.prv.get_asset().get('assets', [])
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        now_ticker = self.pub.get_ticker(f'{crypto_symbol.lower()}_{fiat_symbol.lower()}')
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('sell', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('buy', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }
        now_ticker = self.mxc.get_ticker(f'{crypto_symbol}_{fiat_symbol}')[0]
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('ask', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('bid', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 + fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('Bitbank::buy  amount <= 0')
        self.prv.order(
            pair=f'{crypto_symbol.lower()}_{fiat_symbol.lower()}', price=str(fiat_price_without_fee),
            amount=str(amount), side='buy', order_type='market'
        )

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('Bitbank::sell  amount <= 0')
        self.prv.order(
            pair=f'{crypto_symbol.lower()}_{fiat_symbol.lower()}', price=str(fiat_price_without_fee),
            amount=str(amount), side='sell', order_type='market'
        )

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money * Decimal('0.75')

    def is_trade_fiat_money_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        return amount > 0

# Cell
from decimal import Decimal


class MXC(Exchange):

    def __init__(self):
        super().__init__()
        self.mxc = MXCAPI(os.environ['MXC_ACCESS_KEY'], os.environ['MXC_SECRET_KEY'])
        self.update_trading_specifications()

    def update_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.update_trading_specifications().get((crypto_symbol, fiat_symbol), {})

    def update_trading_specifications(self):
        for symbol_info in self.mxc.get_symbols():
            crypto_symbol, fiat_symbol = symbol_info.get('symbol', '').split('_')
            trading_spec = {}
            if 'quantity_scale' in symbol_info:
                trading_spec['min_trade_unit'] = Decimal('0.1') ** symbol_info.get('quantity_scale', 0)
            if 'min_amount' in symbol_info:
                trading_spec['min_trade_fiat_money_limit'] = Decimal(symbol_info.get('min_amount', '0'))
            if 'maker_fee_rate' in symbol_info:
                trading_spec['fee_rate'] = Decimal(symbol_info.get('maker_fee_rate', '0'))
            if 'limited' in symbol_info:
                trading_spec['liquid'] = symbol_info.get('limited', False)
            self.trading_specifications[(crypto_symbol, fiat_symbol)] = trading_spec
        return self.trading_specifications

    def get_portfolio(self):
        return {
            symbol: Decimal(asset.get('available', '0')) for symbol, asset in self.mxc.get_account_info().items()
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        now_ticker = self.mxc.get_ticker(f'{crypto_symbol}_{fiat_symbol}')[0]
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('ask', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('bid', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 + fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('MXC::buy  amount <= 0')
        self.mxc.place_order(f'{crypto_symbol}_{fiat_symbol}', str(fiat_price_without_fee), str(amount), 'BID', 'IMMEDIATE_OR_CANCEL')

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('MXC::sell  amount <= 0')
        self.mxc.place_order(f'{crypto_symbol}_{fiat_symbol}', str(fiat_price_without_fee), str(amount), 'ASK', 'IMMEDIATE_OR_CANCEL')

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money
        # Just for Bitbank
        return buy_fiat_money <= unused_fiat_money * Decimal('0.75')

    def is_trade_fiat_money_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        # Just for MXC
        return fiat_price_without_fee * amount > self.get_trading_specification(crypto_symbol, fiat_symbol).get('min_trade_fiat_money_limit', 0)

# Cell
import contextlib
import hashlib
import hmac
import os
import requests
import time

from urllib import parse


class MXCAPI(object):

    ROOT_URL = 'https://www.mxc.ceo'
    ERROR_MESSAGES = {
        400: '请求参数无效。',
        401: '签名验证失败。',
        429: '请求过于频繁。',
        10072: '无效的 Access Key。',
        10073: '无效的请求时间。',
        30000: '当前交易对已暂停交易。',
        30001: '当前交易方向不允许下单。',
        30002: '小于最小交易金额。',
        30003: '大于最大交易金额。',
        30004: '持仓不足。',
        30005: '卖出超额。',
        30010: '下单价格超过范围。',
        30016: '暂停交易。',
        30019: '订单集合超出最大允许长度。',
        30020: '受限制的交易对，暂不支持 API 访问。',
        30021: '无效的交易对。',
    }

    def __init__(self, API_KEY, SECRET_KEY):
        self.API_KEY = API_KEY
        self.SECRET_KEY = SECRET_KEY

    @staticmethod
    def _get_server_time():
        return int(time.time())

    def _sign(self, method, path, original_params=None):
        params = {
            'api_key': self.API_KEY,
            'req_time': type(self)._get_server_time(),
        }
        if original_params is not None:
            params.update(original_params)
        params_str = '&'.join('{}={}'.format(k, params[k]) for k in sorted(params))
        to_sign = '\n'.join([method, path, params_str])
        params.update({
            'sign': hmac.new(self.SECRET_KEY.encode(), to_sign.encode(), hashlib.sha256).hexdigest()
        })
        return params

    def _request(self, method, path, params):
        url = '{}{}'.format(type(self).ROOT_URL, path)
        with contextlib.closing(
            requests.request(method, url, params=params)
        ) as response:
            response_json = response.json()
            code = response_json.get('code', 0)
            if code != 200:
                raise Exception(
                    type(self).ERROR_MESSAGES.get(code, response_json.get('msg', '未知错误。'))
                )
            return response_json.get('data', {})

    def get_symbols(self):
        """marget data"""
        method = 'GET'
        path = '/open/api/v2/market/symbols'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_rate_limit(self):
        """rate limit"""
        method = 'GET'
        path = '/open/api/v2/common/rate_limit'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_timestamp(self):
        """get current time"""
        method = 'GET'
        path = '/open/api/v2/common/timestamp'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_ticker(self, symbol):
        """get ticker information"""
        method = 'GET'
        path = '/open/api/v2/market/ticker'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
        }
        return self._request(method, path, params)

    def get_depth(self, symbol, depth):
        """get market depth"""
        method = 'GET'
        path = '/open/api/v2/market/depth'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'depth': depth,
        }
        return self._request(method, path, params)

    def get_deals(self, symbol, limit):
        """get deals records"""
        method = 'GET'
        path = '/open/api/v2/market/deals'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'limit': limit,
        }
        return self._request(method, path, params)

    def get_kline(self, symbol, interval):
        """k-line data"""
        method = 'GET'
        path = '/open/api/v2/market/kline'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'interval': interval,
        }
        return self._request(method, path, params)

    def get_account_info(self):
        """account information"""
        method = 'GET'
        path = '/open/api/v2/account/info'
        params = self._sign(method, path)
        return self._request(method, path, params)

    def _request_with_json(self, method, path, params, json):
        url = '{}{}'.format(type(self).ROOT_URL, path)
        with contextlib.closing(
            requests.request(method, url, params=params, json=json)
        ) as response:
            response_json = response.json()
            code = response_json.get('code', 0)
            if code != 200:
                raise Exception(
                    type(self).ERROR_MESSAGES.get(code, response_json.get('msg', '未知错误。'))
                )
            return response_json.get('data', {})

    def place_order(self, symbol, price, quantity, trade_type, order_type):
        """place order"""
        method = 'POST'
        path = '/open/api/v2/order/place'
        params = self._sign(method, path)
        data = {
            'symbol': symbol,
            'price': price,
            'quantity': quantity,
            'trade_type': trade_type,
            'order_type': order_type,
        }
        return self._request_with_json(method, path, params, data)

    def batch_orders(self, orders):
        """batch order"""
        method = 'POST'
        path = '/open/api/v2/order/place_batch'
        params = self._sign(method, path)
        return self._request_with_json(method, path, params, orders)

    def cancel_order(self, order_id):
        """cancel in batch"""
        method = 'DELETE'
        path = '/open/api/v2/order/cancel'

        origin_trade_no = order_id
        if isinstance(order_id, list):
            origin_trade_no = parse.quote(','.join(order_id))
        params = self._sign(method, path, original_params={'order_ids': origin_trade_no})
        if isinstance(order_id, list):
            params['order_ids'] = ','.join(order_id)

        return self._request(method, path, params)

    def get_open_orders(self, symbol):
        """current orders"""
        method = 'GET'
        path = '/open/api/v2/order/open_orders'

        original_params = {
            'symbol': symbol,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def get_all_orders(self, symbol, trade_type):
        """order list"""
        method = 'GET'
        path = '/open/api/v2/order/list'

        original_params = {
            'symbol': symbol,
            'trade_type': trade_type,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def query_order(self, order_id):
        """query order"""
        method = 'GET'
        path = '/open/api/v2/order/query'

        origin_trade_no = order_id
        if isinstance(order_id, list):
            origin_trade_no = parse.quote(','.join(order_id))
        original_params = {
            'order_ids': origin_trade_no,
        }
        params = self._sign(method, path, original_params=original_params)
        if isinstance(order_id, list):
            params['order_ids'] = ','.join(order_id)

        return self._request(method, path, params)

    def get_deal_orders(self, symbol):
        """account deal records"""
        method = 'GET'
        path = '/open/api/v2/order/deals'

        original_params = {
            'symbol': symbol,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def get_deal_detail(self, order_id):
        """deal detail"""
        method = 'GET'
        path = '/open/api/v2/order/deal_detail'

        original_params = {
            'order_id': order_id,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

# Cell
from decimal import Decimal


class MXC(Exchange):

    def __init__(self):
        super().__init__()
        self.mxc = MXCAPI(os.environ['MXC_ACCESS_KEY'], os.environ['MXC_SECRET_KEY'])
        self.update_trading_specifications()

    def update_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.update_trading_specifications().get((crypto_symbol, fiat_symbol), {})

    def update_trading_specifications(self):
        for symbol_info in self.mxc.get_symbols():
            crypto_symbol, fiat_symbol = symbol_info.get('symbol', '').split('_')
            trading_spec = {}
            if 'quantity_scale' in symbol_info:
                trading_spec['min_trade_unit'] = Decimal('0.1') ** symbol_info.get('quantity_scale', 0)
            if 'min_amount' in symbol_info:
                trading_spec['min_trade_fiat_money_limit'] = Decimal(symbol_info.get('min_amount', '0'))
            if 'maker_fee_rate' in symbol_info:
                trading_spec['fee_rate'] = Decimal(symbol_info.get('maker_fee_rate', '0'))
            if 'limited' in symbol_info:
                trading_spec['liquid'] = symbol_info.get('limited', False)
            self.trading_specifications[(crypto_symbol, fiat_symbol)] = trading_spec
        return self.trading_specifications

    def get_portfolio(self):
        return {
            symbol: Decimal(asset.get('available', '0')) for symbol, asset in self.mxc.get_account_info().items()
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        now_ticker = self.mxc.get_ticker(f'{crypto_symbol}_{fiat_symbol}')[0]
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('ask', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('bid', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 + fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('MXC::buy  amount <= 0')
        self.mxc.place_order(f'{crypto_symbol}_{fiat_symbol}', str(fiat_price_without_fee), str(amount), 'BID', 'IMMEDIATE_OR_CANCEL')

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('MXC::sell  amount <= 0')
        self.mxc.place_order(f'{crypto_symbol}_{fiat_symbol}', str(fiat_price_without_fee), str(amount), 'ASK', 'IMMEDIATE_OR_CANCEL')

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money

    def is_trade_fiat_money_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        # Just for MXC
        return fiat_price_without_fee * amount > self.get_trading_specification(crypto_symbol, fiat_symbol).get('min_trade_fiat_money_limit', 0)

# Cell
import contextlib
import hashlib
import hmac
import os
import requests
import time

from urllib import parse


class MXCAPI(object):

    ROOT_URL = 'https://www.mxc.ceo'
    ERROR_MESSAGES = {
        400: '请求参数无效。',
        401: '签名验证失败。',
        429: '请求过于频繁。',
        10072: '无效的 Access Key。',
        10073: '无效的请求时间。',
        30000: '当前交易对已暂停交易。',
        30001: '当前交易方向不允许下单。',
        30002: '小于最小交易金额。',
        30003: '大于最大交易金额。',
        30004: '持仓不足。',
        30005: '卖出超额。',
        30010: '下单价格超过范围。',
        30016: '暂停交易。',
        30019: '订单集合超出最大允许长度。',
        30020: '受限制的交易对，暂不支持 API 访问。',
        30021: '无效的交易对。',
    }

    def __init__(self, API_KEY, SECRET_KEY):
        self.API_KEY = API_KEY
        self.SECRET_KEY = SECRET_KEY

    @staticmethod
    def _get_server_time():
        return int(time.time())

    def _sign(self, method, path, original_params=None):
        params = {
            'api_key': self.API_KEY,
            'req_time': type(self)._get_server_time(),
        }
        if original_params is not None:
            params.update(original_params)
        params_str = '&'.join('{}={}'.format(k, params[k]) for k in sorted(params))
        to_sign = '\n'.join([method, path, params_str])
        params.update({
            'sign': hmac.new(self.SECRET_KEY.encode(), to_sign.encode(), hashlib.sha256).hexdigest()
        })
        return params

    def _request(self, method, path, params):
        url = '{}{}'.format(type(self).ROOT_URL, path)
        with contextlib.closing(
            requests.request(method, url, params=params)
        ) as response:
            response_json = response.json()
            code = response_json.get('code', 0)
            if code != 200:
                raise Exception(
                    type(self).ERROR_MESSAGES.get(code, response_json.get('msg', '未知错误。'))
                )
            return response_json.get('data', {})

    def get_symbols(self):
        """marget data"""
        method = 'GET'
        path = '/open/api/v2/market/symbols'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_rate_limit(self):
        """rate limit"""
        method = 'GET'
        path = '/open/api/v2/common/rate_limit'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_timestamp(self):
        """get current time"""
        method = 'GET'
        path = '/open/api/v2/common/timestamp'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_ticker(self, symbol):
        """get ticker information"""
        method = 'GET'
        path = '/open/api/v2/market/ticker'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
        }
        return self._request(method, path, params)

    def get_depth(self, symbol, depth):
        """get market depth"""
        method = 'GET'
        path = '/open/api/v2/market/depth'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'depth': depth,
        }
        return self._request(method, path, params)

    def get_deals(self, symbol, limit):
        """get deals records"""
        method = 'GET'
        path = '/open/api/v2/market/deals'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'limit': limit,
        }
        return self._request(method, path, params)

    def get_kline(self, symbol, interval):
        """k-line data"""
        method = 'GET'
        path = '/open/api/v2/market/kline'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'interval': interval,
        }
        return self._request(method, path, params)

    def get_account_info(self):
        """account information"""
        method = 'GET'
        path = '/open/api/v2/account/info'
        params = self._sign(method, path)
        return self._request(method, path, params)

    def _request_with_json(self, method, path, params, json):
        url = '{}{}'.format(type(self).ROOT_URL, path)
        with contextlib.closing(
            requests.request(method, url, params=params, json=json)
        ) as response:
            response_json = response.json()
            code = response_json.get('code', 0)
            if code != 200:
                raise Exception(
                    type(self).ERROR_MESSAGES.get(code, response_json.get('msg', '未知错误。'))
                )
            return response_json.get('data', {})

    def place_order(self, symbol, price, quantity, trade_type, order_type):
        """place order"""
        method = 'POST'
        path = '/open/api/v2/order/place'
        params = self._sign(method, path)
        data = {
            'symbol': symbol,
            'price': price,
            'quantity': quantity,
            'trade_type': trade_type,
            'order_type': order_type,
        }
        return self._request_with_json(method, path, params, data)

    def batch_orders(self, orders):
        """batch order"""
        method = 'POST'
        path = '/open/api/v2/order/place_batch'
        params = self._sign(method, path)
        return self._request_with_json(method, path, params, orders)

    def cancel_order(self, order_id):
        """cancel in batch"""
        method = 'DELETE'
        path = '/open/api/v2/order/cancel'

        origin_trade_no = order_id
        if isinstance(order_id, list):
            origin_trade_no = parse.quote(','.join(order_id))
        params = self._sign(method, path, original_params={'order_ids': origin_trade_no})
        if isinstance(order_id, list):
            params['order_ids'] = ','.join(order_id)

        return self._request(method, path, params)

    def get_open_orders(self, symbol):
        """current orders"""
        method = 'GET'
        path = '/open/api/v2/order/open_orders'

        original_params = {
            'symbol': symbol,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def get_all_orders(self, symbol, trade_type):
        """order list"""
        method = 'GET'
        path = '/open/api/v2/order/list'

        original_params = {
            'symbol': symbol,
            'trade_type': trade_type,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def query_order(self, order_id):
        """query order"""
        method = 'GET'
        path = '/open/api/v2/order/query'

        origin_trade_no = order_id
        if isinstance(order_id, list):
            origin_trade_no = parse.quote(','.join(order_id))
        original_params = {
            'order_ids': origin_trade_no,
        }
        params = self._sign(method, path, original_params=original_params)
        if isinstance(order_id, list):
            params['order_ids'] = ','.join(order_id)

        return self._request(method, path, params)

    def get_deal_orders(self, symbol):
        """account deal records"""
        method = 'GET'
        path = '/open/api/v2/order/deals'

        original_params = {
            'symbol': symbol,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def get_deal_detail(self, order_id):
        """deal detail"""
        method = 'GET'
        path = '/open/api/v2/order/deal_detail'

        original_params = {
            'order_id': order_id,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

# Cell
import base64
import copy
from decimal import Decimal
import os
import yaml


class Status(object):

    PATH = os.getenv('ROBOT_PATH') or '.'
    STATUS_FILE = f'{PATH}/robot-status'
    TMPFILE = f'{PATH}/_tmp'

    def __init__(self, robot_name, crypto_symbol, fiat_symbol, trade_unit, max_used_fiat_money_limit=Decimal('Infinity')):
        self.robot_name = robot_name
        self.crypto_symbol, self.fiat_symbol = crypto_symbol, fiat_symbol
        self.trade_unit = trade_unit

        self.max_used_fiat_money_limit = max_used_fiat_money_limit
        self.unused_fiat_money = None

        self.now_buy_fiat_price = Decimal('Infinity')
        self.now_sell_fiat_price = 0

        self.now_buy_fiat_price_without_fee = Decimal('Infinity')
        self.now_sell_fiat_price_without_fee = 0

        self.sample_number = 0
        self.trade_count = 0

        self.buy_count = 0
        self.clear_bought_status()

        self.sell_count = 0
        self.clear_sold_status()

        self.last_transaction = None
        self.total_gained_fiat_money = 0

    def get_max_used_fiat_money(self, new_unused_fiat_money=None):
        if isinstance(new_unused_fiat_money, Decimal):
            self.unused_fiat_money = new_unused_fiat_money
        max_used_fiat_money = self.unused_fiat_money + self.used_fiat_money
#         max_used_fiat_money = self.unused_fiat_money + self.total_gained_fiat_money
        if max_used_fiat_money > self.max_used_fiat_money_limit:
            return self.max_used_fiat_money_limit
        return max_used_fiat_money

    def get_usage(self, new_unused_fiat_money=None):
        max_used_fiat_money = self.get_max_used_fiat_money(new_unused_fiat_money)
        if max_used_fiat_money == 0:
            return 0
        return self.used_fiat_money / max_used_fiat_money

    def get_robot_title(self):
        robot_status_description = f'{self.get_usage() * 100:.2f}%'
        if self.bought_average_fiat_price is not None:
            robot_status_description = f'{self.bought_average_fiat_price:.4f} / {robot_status_description}'
        return f'{self.robot_name} ({robot_status_description}) at {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}'

    def is_fiat_price_lower_than_average(self):
        return self.bought_average_fiat_price is not None and self.now_buy_fiat_price < self.bought_average_fiat_price

    def is_fiat_price_higher_than_average(self):
        return self.bought_average_fiat_price is not None and self.now_sell_fiat_price > self.bought_average_fiat_price

    def get_gain_fiat_money(self):
        self.gain_fiat_money = self.now_sell_fiat_price * self.bought_amount - self.used_fiat_money
        return self.now_sell_fiat_price * self.bought_amount - self.used_fiat_money

    def get_total_gain_fiat_money(self):
        return self.total_gained_fiat_money + self.get_gain_fiat_money()

    def __str__(self):
        sell_fiat_price_description = f'{self.now_sell_fiat_price:.4f}'
        if self.bought_average_fiat_price is not None:
            diff_fiat_price = self.now_sell_fiat_price - self.bought_average_fiat_price
            sell_fiat_price_description = f'{diff_fiat_price:.4f} = {self.now_sell_fiat_price:.4f} - {self.bought_average_fiat_price:.4f}'
        return (
            f'GAIN {self.get_total_gain_fiat_money():+.4f} = {self.total_gained_fiat_money:+.4f} {self.get_gain_fiat_money():+.4f} {self.fiat_symbol} in total by {self.get_robot_title()} after\n'
            f'SELL {self.bought_amount:.4f} {self.crypto_symbol} for {sell_fiat_price_description} {self.fiat_symbol}/{self.crypto_symbol}. BUY for {self.now_buy_fiat_price:.4f} {self.fiat_symbol}/{self.crypto_symbol}.\n'
        )

    def get_max_sold_unit_amount(self):
        return self.bought_unit_amount + self.sold_unit_amount

    def estimate_gained_fiat_money(self, sell_unit_amount, sell_fiat_price=None):
        if sell_unit_amount < 0:
            raise Exception('Status::estimate_gained_fiat_money  sell_unit_amount < 0')
        if self.bought_average_fiat_price is None:
            return None
        if sell_fiat_price is None:
            sell_fiat_price = self.now_sell_fiat_price
        return (sell_fiat_price - self.bought_average_fiat_price) * (self.trade_unit * sell_unit_amount)

    @classmethod
    def get_status_file(cls):
        return f'{cls.STATUS_FILE}.yaml'

    def get_file_name_suffix(self):
        return base64.b64encode(self.robot_name.encode('ascii')).decode('ascii')

    def get_unique_status_file(self):
        return f'{type(self).STATUS_FILE}-{self.get_file_name_suffix()}.yaml'

    def read(self):
        status_file = self.get_unique_status_file()
        if not os.path.exists(status_file):
            return self
        with open(status_file, 'r') as f:
            self.__dict__.update(
                yaml.load(f, Loader=yaml.FullLoader)
            )
        for i in self.__dict__:
            if isinstance(self.__dict__[i], float):
                self.__dict__[i] = Decimal(repr(self.__dict__[i]))
        return self

    def write(self):
        this = copy.deepcopy(self)
        for i in this.__dict__:
            if isinstance(this.__dict__[i], Decimal):
                this.__dict__[i] = float(this.__dict__[i])
        tmp_file_name = f'{type(this).TMPFILE}-{self.get_file_name_suffix()}'
        with open(tmp_file_name, 'w') as f:
            yaml.dump(this.__dict__, f, sort_keys=False)
        os.replace(tmp_file_name, this.get_unique_status_file())

    def clear_bought_status(self):
        self.bought_unit_amount = 0
        self.used_fiat_money = 0
        self.bought_amount = 0
        self.bought_average_fiat_price = None

    def clear_sold_status(self):
        self.sold_unit_amount = 0
        self.got_fiat_money = 0
        self.sold_amount = 0
        self.sold_average_fiat_price = None

    def trim_bought_status(self):
        if self.bought_unit_amount > 0:
            self.bought_amount = self.trade_unit * self.bought_unit_amount
            self.bought_average_fiat_price = self.used_fiat_money / self.bought_amount
        else:
            self.clear_bought_status()

    def trim_sold_status(self):
        if self.sold_unit_amount > 0:
            self.sold_amount = self.trade_unit * self.sold_unit_amount
            self.sold_average_fiat_price = self.got_fiat_money / self.sold_amount
        else:
            self.clear_sold_status()

    def update_bought_status(self, **trade):
        buy_fiat_price = trade.get('fiat_price', self.now_buy_fiat_price)
        buy_unit_amount = trade.get('unit_amount', 0)
        self.bought_unit_amount += buy_unit_amount
        self.used_fiat_money += buy_fiat_price * (self.trade_unit * buy_unit_amount)
        self.trim_bought_status()

    def update_sold_status(self, **trade):
        sell_fiat_price = trade.get('fiat_price', self.now_sell_fiat_price)
        sell_unit_amount = trade.get('unit_amount', 0)
        self.sold_unit_amount += sell_unit_amount
        self.got_fiat_money += sell_fiat_price * (self.trade_unit * sell_unit_amount)
        self.trim_sold_status()

    def trim_trade_status(self):
        self.trim_bought_status()
        self.trim_sold_status()

    def update(self, status=None):
        if isinstance(status, type(self)):
            self.__dict__.update(status.__dict__)
        if isinstance(status, dict):
            self.__dict__.update(status)
        self.trim_trade_status()

# Cell
import os
import time
import yaml


class Fetcher(object):

    LIQUIDITY_YAML = './crypto-liquidity.yaml'
    TRADING_SPEC_YAML = './crypto-trading-spec.yaml'

    def __init__(self, exchange):
        self.mxc = MXCAPI(os.environ['MXC_ACCESS_KEY'], os.environ['MXC_SECRET_KEY'])
        self.exchange = exchange

    @staticmethod
    def write(yaml_data, yaml_file_path):
        with open(yaml_file_path, 'w') as f:
            yaml.dump(yaml_data, f, sort_keys=False)

    @staticmethod
    def read(yaml_file_path):
        if not os.path.exists(yaml_file_path):
            return {}
        with open(yaml_file_path) as f:
            return yaml.load(f, Loader=yaml.FullLoader)

    @staticmethod
    def extract_symbols(liquidity):
        symbol_and_liquid = liquidity.items()
        symbols = {
            symbol for symbol, _ in symbol_and_liquid
        }
        liquid_symbols = {
            symbol for symbol, liquid in symbol_and_liquid if liquid == True
        }
        return symbols, liquid_symbols

    def fetch_symbols(self):
        liquidity = {
            trading_spec['symbol']: trading_spec.get('limited', False) for trading_spec in self.mxc.get_symbols()
        }
        type(self).write(liquidity, type(self).LIQUIDITY_YAML)
        return type(self).extract_symbols(liquidity)

    def read_symbols(self):
        liquidity = type(self).read(type(self).LIQUIDITY_YAML)
        return type(self).extract_symbols(liquidity)

    def get_trading_spec(self, crypto_symbol, fiat_symbol):
        trading_spec = self.exchange.get_trading_specification(crypto_symbol, fiat_symbol)
        trading_specs = type(self).read(type(self).TRADING_SPEC_YAML)
        trading_specs.update({
            f'{crypto_symbol}-{fiat_symbol}': trading_spec
        })
        type(self).write(trading_specs, type(self).TRADING_SPEC_YAML)
        return trading_spec

# Cell
class Portfolio(object):
    def __init__(self, portfolio):
        if isinstance(portfolio, type(self)):
            self.__dict__.update(portfolio.__dict__)
        if isinstance(portfolio, dict):
            self.__dict__.update(portfolio)
        if isinstance(portfolio, list):
            self.__dict__.update(dict(portfolio))

# Cell
import copy
from datetime import datetime
from decimal import Decimal
import os


class BookKeeper(object):

    def __init__(self, exchange, status_list):
        self.exchange = exchange

        self.status_list = status_list
        self.portfolio = self.get_portfolio()
        for status in self.status_list:
            status.unused_fiat_money = getattr(self.portfolio, status.fiat_symbol)

        self.estimate_functions = {
            'buy': self.estimate_status_by_buying,
            'sell': self.estimate_status_by_selling
        }

    def __enter__(self):
        self.fsh = open('sample-history.txt', 'a', 1)
        self.fth = open('transaction-history.txt', 'a', 1)
#         self.fth_origin = open('transaction-history-origin.txt', 'a', 1)
        type(self).fth = open('transaction-exception.txt', 'a', 1)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.fsh.close()
        self.fth.close()
#         self.fth_origin.close()
        type(self).fth.close()
        if exc_type == Exception and str(exc_value) == MXCAPI.ERROR_MESSAGES[30020]:
            return True
        return False

    def get_portfolio(self):
        return Portfolio(self.exchange.get_portfolio())

    def estimate_status_list(self):
        old_portfolio = self.portfolio
        new_portfolio = self.get_portfolio()
        self.portfolio = new_portfolio

        new_status_list = []
        for status in self.status_list:
            new_status = type(self).estimate_status(status, old_portfolio, new_portfolio)
            new_status_list.append(new_status)
            if new_status is not status:
                self.fth.write(new_status.last_transaction)

        return new_status_list

    @classmethod
    def estimate_status(cls, status, old_portfolio, new_portfolio):
        old_fiat_money = getattr(old_portfolio, status.fiat_symbol)
        old_amount = getattr(old_portfolio, status.crypto_symbol, 0)
        new_fiat_money = getattr(new_portfolio, status.fiat_symbol)
        new_amount = getattr(new_portfolio, status.crypto_symbol, 0)

        if old_amount > new_amount and old_fiat_money < new_fiat_money:
            amount = old_amount - new_amount
            fiat_price = (new_fiat_money - old_fiat_money) / amount

            old_status_amount = status.bought_amount
            new_status = cls.estimate_status_by_selling(
                status = status,
                unit_amount = amount / status.trade_unit,
                fiat_price = fiat_price,
                buy_unit_amount = min(0, new_amount - old_status_amount) / status.trade_unit,
                new_unused_fiat_money = new_fiat_money
            )

            now_sell_fiat_price = status.now_sell_fiat_price
            if now_sell_fiat_price == Decimal('0'):
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status
            if abs(fiat_price - now_sell_fiat_price) / now_sell_fiat_price > Decimal(50/100):
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status

            return new_status

        if old_amount < new_amount and old_fiat_money > new_fiat_money:
            amount = new_amount - old_amount
            fiat_price = (old_fiat_money - new_fiat_money) / amount

            new_status = cls.estimate_status_by_buying(
                status = status,
                unit_amount = amount / status.trade_unit,
                fiat_price = fiat_price,
                new_unused_fiat_money = new_fiat_money
            )

            now_buy_fiat_price = status.now_buy_fiat_price
            if now_buy_fiat_price == Decimal('Infinity'):
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status
            if abs(fiat_price - now_buy_fiat_price) / now_buy_fiat_price > Decimal(50) / 100:
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status

            return new_status

        if old_amount > new_amount and old_fiat_money >= new_fiat_money:
            amount = old_amount - new_amount
            old_status_amount = status.bought_amount
            return cls.estimate_status_by_utilizing(
                status = status,
                unit_amount = amount / status.trade_unit,
                buy_unit_amount = min(0, new_amount - old_status_amount) / status.trade_unit,
                new_unused_fiat_money = new_fiat_money
            )

        if old_amount < new_amount and old_fiat_money <= new_fiat_money:
            amount = new_amount - old_amount
            return cls.estimate_status_by_receiving(
                status = status,
                unit_amount = amount / status.trade_unit,
                new_unused_fiat_money = new_fiat_money
            )

        status.unused_fiat_money = new_fiat_money
        return status

    @staticmethod
    def estimate_status_by_receiving(status, unit_amount, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_receiving: unit_amount <= 0')

        old_status = status
        new_status = copy.deepcopy(old_status)

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'RECEIVED {amount:.4f} = -{old_amount:.4f} ({old_percentage:.2f}%) +{new_amount:.4f} ({new_percentage:.2f}%) {amount:+.4f} {new_status.crypto_symbol}\n'
        )

        return new_status

    @staticmethod
    def estimate_status_by_utilizing(status, unit_amount, buy_unit_amount=None, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_utilizing: unit_amount <= 0')
        if buy_unit_amount is None:
            buy_unit_amount = -unit_amount

        old_status = status
        new_status = copy.deepcopy(old_status)

        if new_status.bought_average_fiat_price is not None:
            new_status.update_bought_status(fiat_price=new_status.bought_average_fiat_price, unit_amount=buy_unit_amount)

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'UTILIZED {amount:.4f} = +{old_amount:.4f} ({old_percentage:.2f}%) -{new_amount:.4f} ({new_percentage:.2f}%) {amount-(old_amount-new_amount):+.4f} {new_status.crypto_symbol}\n'
        )

        return new_status

    @staticmethod
    def estimate_status_by_buying(status, unit_amount, fiat_price=None, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_buying: unit_amount <= 0')
        if fiat_price is None:
            fiat_price = status.now_buy_fiat_price

        old_status = status
        new_status = copy.deepcopy(old_status)

        new_status.buy_count += 1
        new_status.update_bought_status(fiat_price=fiat_price, unit_amount=unit_amount)

        new_status.update(
            status = {
                'sold_unit_amount': 0
            }
        )

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'BOUGHT {amount:.4f} = -{old_amount:.4f} ({old_percentage:.2f}%) +{new_amount:.4f} ({new_percentage:.2f}%) {new_status.crypto_symbol} for {fiat_price:.4f} {new_status.fiat_symbol}/{new_status.crypto_symbol}:'
            f' NO.{new_status.trade_count + 1}-{new_status.buy_count} at {datetime.now()}\n'
        )

        return new_status

    @staticmethod
    def estimate_status_by_selling(status, unit_amount, fiat_price=None, buy_unit_amount=None, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_selling: unit_amount <= 0')
        if fiat_price is None:
            fiat_price = status.now_sell_fiat_price
        if buy_unit_amount is None:
            buy_unit_amount = -unit_amount

        old_status = status
        new_status = copy.deepcopy(old_status)

        new_status.sell_count += 1
        if new_status.bought_average_fiat_price is not None:
            new_status.update_bought_status(fiat_price=new_status.bought_average_fiat_price, unit_amount=buy_unit_amount)
        new_status.update_sold_status(fiat_price=fiat_price, unit_amount=unit_amount)

        if new_status.bought_unit_amount == 0:
            new_status.update(
                status = {
                    'trade_count': new_status.trade_count + 1,
                    'buy_count': 0,
                    'sell_count': 0
                }
            )

        gained_fiat_money = old_status.estimate_gained_fiat_money(unit_amount, fiat_price)
        if gained_fiat_money is None:
            gained_fiat_money = 0
        new_status.total_gained_fiat_money += gained_fiat_money

        old_avg_price = old_status.bought_average_fiat_price
        if old_avg_price is None:
            old_avg_price = 0
        diff_price = fiat_price - old_avg_price

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'GAINED {gained_fiat_money:+.4f} {new_status.fiat_symbol}: GAINED {new_status.total_gained_fiat_money:+.4f} {new_status.fiat_symbol} in total at {datetime.now()} after\n'
            f'SOLD {amount:.4f} = +{old_amount:.4f} ({old_percentage:.2f}%) -{new_amount:.4f} ({new_percentage:.2f}%) {amount-(old_amount-new_amount):+.4f} {new_status.crypto_symbol}'
            f' for {diff_price:.4f} = {fiat_price:.4f} - {old_avg_price:.4f} {new_status.fiat_symbol}/{new_status.crypto_symbol}: NO.{new_status.trade_count + 1}-{new_status.sell_count}\n'
        )

        return new_status

# Cell
import math
from decimal import Decimal
from scipy import optimize as opt
from numpy.lib import scimath
import time


class Trader(object):

    TRADE_RATE = Decimal('Infinity')

    SAMPLE_INTERVAL = 60
    HAPPY_COOLING_INTERVAL = 30
    SAD_COOLING_INTERVAL = 60 * 6

    LOSSABLE_UNIT_CC_SELL_JPY = Decimal('Infinity')

    MAX_GAIN_JPY = Decimal('Infinity') # useless
    MAX_LOSS_JPY = Decimal('Infinity') # useless
    MAX_LOST_JPY = Decimal('Infinity')

    def __init__(self, exchange, status, gainable_unit_cc_sold_ratio, lossable_unit_cc_bought_ratio, min_trade_fiat_price, max_trade_fiat_price):
        self.exchange = exchange

        self.status = status

        self.gainable_unit_cc_sold_ratio = gainable_unit_cc_sold_ratio # TODO: self-adaptive by trend analysis
        self.lossable_unit_cc_bought_ratio = lossable_unit_cc_bought_ratio

        self.min_unit_cc_trade_fiat_money = min_trade_fiat_price
        self.max_unit_cc_trade_fiat_money = max_trade_fiat_price

    def get_price(self):
        return self.exchange.get_price(self.status.crypto_symbol, self.status.fiat_symbol)

    def buy(self, unit_amount):
        if unit_amount <= 0:
            raise Exception('Trader::buy  unit_amount <= 0')
        amount = self.status.trade_unit * unit_amount
        self.exchange.buy(self.status.crypto_symbol, self.status.fiat_symbol, amount, self.status.now_buy_fiat_price_without_fee)

#         old_status = self.status
#         new_status = copy.deepcopy(old_status)

#         new_status.buy_count += 1
#         new_status.update_bought_status(fiat_price=fiat_price, unit_amount=unit_amount)

#         old_amount = old_status.bought_amount
#         old_percentage = old_status.get_usage() * 100
#         new_amount = new_status.bought_amount
#         new_percentage = new_status.get_usage(getattr(self.portfolio, self.status.fiat_symbol)) * 100

#         bookkeeper.fth_origin.write(
#             f'BOUGHT {amount:.4f} = -{old_amount:.4f} ({old_percentage:.2f}%) +{new_amount:.4f} ({new_percentage:.2f}%) CELO for {fiat_price:.4f} USDT/CELO:'
#             f' NO.{new_status.trade_count + 1}-{new_status.buy_count} at {datetime.now()}\n\n'
#         )

    def sell(self, unit_amount):
        if unit_amount <= 0:
            raise Exception('Trader::sell  unit_amount <= 0')
        amount = self.status.trade_unit * unit_amount
        self.exchange.sell(self.status.crypto_symbol, self.status.fiat_symbol, amount, self.status.now_sell_fiat_price_without_fee)

#         old_status = self.status
#         new_status = copy.deepcopy(old_status)

#         new_status.sell_count += 1
#         new_status.update_bought_status(fiat_price=new_status.bought_average_fiat_price, unit_amount=-unit_amount)
#         new_status.update_sold_status(fiat_price=fiat_price, unit_amount=unit_amount)

#         old_avg_price = old_status.bought_average_fiat_price
#         diff_price = fiat_price - old_avg_price
#         gained_fiat_money = old_status.estimate_gained_fiat_money(unit_amount, fiat_price)
#         new_status.total_gained_fiat_money += gained_fiat_money

#         old_amount = old_status.bought_amount
#         old_percentage = old_status.get_usage() * 100
#         new_amount = new_status.bought_amount
#         new_percentage = new_status.get_usage(getattr(self.portfolio, self.status.fiat_symbol)) * 100

#         bookkeeper.fth_origin.write(
#             f'GAINED {gained_fiat_money:+.4f} USDT: GAINED {new_status.total_gained_fiat_money:+.4f} USDT in total at {datetime.now()}\n'
#             f'SOLD {amount:.4f} = +{old_amount:.4f} ({old_percentage:.2f}%) -{new_amount:.4f} ({new_percentage:.2f}%) CELO'
#             f' for {diff_price:.4f} = {fiat_price:.4f} - {old_avg_price:.4f} USDT/CELO: NO.{new_status.trade_count + 1}-{new_status.sell_count}\n\n'
#         )

    def has_buyable_fiat_price(self):
        return self.status.now_buy_fiat_price > self.min_unit_cc_trade_fiat_money and self.status.now_buy_fiat_price < self.max_unit_cc_trade_fiat_money

    def get_buy_unit_amount(self):
        status = self.status

        used_fiat_money = float(status.used_fiat_money)
        unit_cc_diff_jpy = float(abs(status.bought_average_fiat_price - status.now_buy_fiat_price))

        lossable_unit_cc_bought_jpy = (status.bought_average_fiat_price - self.min_unit_cc_trade_fiat_money) * self.lossable_unit_cc_bought_ratio
        status.min_bought_average_fiat_price = status.bought_average_fiat_price - lossable_unit_cc_bought_jpy

        if status.used_fiat_money >= status.get_max_used_fiat_money():
            status.max_next_buy_fiat_price = Decimal('-Infinity')
            return 0

        # Minimum Action Price Difference
        min_unit_cc_diff_jpy = float(lossable_unit_cc_bought_jpy) / scimath.log(float(status.get_max_used_fiat_money() / status.used_fiat_money))
        status.max_next_buy_fiat_price = status.bought_average_fiat_price - Decimal(repr(min_unit_cc_diff_jpy)) * status.now_buy_fiat_price / status.bought_average_fiat_price

        bought_average_fiat_price = float(status.bought_average_fiat_price)
        now_buy_fiat_price = float(status.now_buy_fiat_price)
        trade_unit = float(status.trade_unit)

        return math.ceil(
            used_fiat_money * opt.fsolve(
                lambda c: [
                    (
                        unit_cc_diff_jpy - min_unit_cc_diff_jpy * scimath.log(1 + c[0]) * (bought_average_fiat_price * c[0] + now_buy_fiat_price) / (bought_average_fiat_price * c[0])
                    ).real
                ],
                [-0.5]
            )[0] / now_buy_fiat_price / trade_unit
        )

    def get_sell_unit_amount(self):
        status = self.status

        if status.bought_average_fiat_price is None:
            return 0

        sold_unit_amount = float(status.sold_unit_amount)
        unit_cc_diff_jpy = float(abs(status.now_sell_fiat_price - status.sold_average_fiat_price))

        status.max_sold_average_fiat_price = status.bought_average_fiat_price * (1 + self.gainable_unit_cc_sold_ratio)

        if status.sold_unit_amount >= status.get_max_sold_unit_amount():
            status.min_next_sell_fiat_price = Decimal('Infinity')
            return 0

        min_unit_cc_diff_jpy = float(status.max_sold_average_fiat_price - status.sold_average_fiat_price) / scimath.log(float(status.get_max_sold_unit_amount() / status.sold_unit_amount))
        status.min_next_sell_fiat_price = status.sold_average_fiat_price + Decimal(repr(min_unit_cc_diff_jpy))

        c = opt.fsolve(
            lambda c: [
                (
                    unit_cc_diff_jpy - min_unit_cc_diff_jpy * scimath.log(1 + c[0]) * (c[0] + 1) / c[0]
                ).real
            ],
            [-0.5]
        )[0]

        if c < -1:
            return status.bought_unit_amount

        if c < 0:
            return 0

        return math.ceil(sold_unit_amount * c)

    def check_and_trade(self):
        status = self.status

        min_trade_fiat_money_limit = self.exchange.get_trading_specification(
            status.crypto_symbol, status.fiat_symbol
        ).get('min_trade_fiat_money_limit', 0)

        status.update(self.get_price())

        please_sell_unit_amount = 0

        if status.sample_number % type(self).TRADE_RATE == 0 and status.is_fiat_price_higher_than_average():
            please_sell_unit_amount = math.ceil(min_trade_fiat_money_limit / status.now_sell_fiat_price_without_fee / status.trade_unit)
            cooling_interval = type(self).HAPPY_COOLING_INTERVAL

        if status.sold_unit_amount == 0 and status.is_fiat_price_higher_than_average():
            please_sell_unit_amount = min(
                math.ceil(min_trade_fiat_money_limit / status.now_sell_fiat_price_without_fee / status.trade_unit),
                status.bought_unit_amount
            )
            cooling_interval = type(self).HAPPY_COOLING_INTERVAL

        if status.sold_unit_amount > 0 and status.now_sell_fiat_price > status.sold_average_fiat_price:
            trade_unit_amount = min(self.get_sell_unit_amount(), status.bought_unit_amount)
            if trade_unit_amount > 0:
                please_sell_unit_amount = trade_unit_amount
                cooling_interval = type(self).HAPPY_COOLING_INTERVAL

        gained_fiat_money = status.estimate_gained_fiat_money(status.bought_unit_amount)
        if gained_fiat_money is not None and gained_fiat_money > type(self).MAX_GAIN_JPY:
            please_sell_unit_amount = status.bought_unit_amount
            cooling_interval = type(self).HAPPY_COOLING_INTERVAL

        if gained_fiat_money is not None and gained_fiat_money < -type(self).MAX_LOSS_JPY:
            please_sell_unit_amount = status.bought_unit_amount
            cooling_interval = type(self).SAD_COOLING_INTERVAL

        if status.bought_average_fiat_price is not None and status.now_sell_fiat_price < status.bought_average_fiat_price - type(self).LOSSABLE_UNIT_CC_SELL_JPY and status.get_usage() > 90/100:
            please_sell_unit_amount = status.bought_unit_amount
            cooling_interval = type(self).SAD_COOLING_INTERVAL

#         if status.bought_unit_amount > 0 and status.now_sell_fiat_price < self.min_unit_cc_trade_fiat_money:
#             please_sell_unit_amount = status.bought_unit_amount
#             cooling_interval = type(self).SAD_COOLING_INTERVAL

        if self.exchange.is_trade_fiat_money_larger_than_limit(
            status.crypto_symbol,
            status.fiat_symbol,
            status.trade_unit * please_sell_unit_amount,
            status.now_sell_fiat_price_without_fee
        ):
            self.sell(please_sell_unit_amount)
            status.sample_number = 0
            return cooling_interval, 'sell', please_sell_unit_amount

        please_buy_unit_amount = 0

        init_buy_jpy = status.get_max_used_fiat_money() / Decimal(math.exp(self.lossable_unit_cc_bought_ratio / (1 - self.lossable_unit_cc_bought_ratio)))
        if status.used_fiat_money == 0 and self.exchange.has_enough_unused_fiat_money(init_buy_jpy, status.unused_fiat_money) and self.has_buyable_fiat_price():
            please_buy_unit_amount = math.ceil(init_buy_jpy / status.now_buy_fiat_price / status.trade_unit)

        if status.used_fiat_money < init_buy_jpy and status.is_fiat_price_lower_than_average() and self.exchange.has_enough_unused_fiat_money(init_buy_jpy - status.used_fiat_money, status.unused_fiat_money) and self.has_buyable_fiat_price():
            please_buy_unit_amount = math.ceil((init_buy_jpy - status.used_fiat_money) / status.now_buy_fiat_price / status.trade_unit)

        if status.used_fiat_money >= init_buy_jpy - min_trade_fiat_money_limit and status.is_fiat_price_lower_than_average():
            trade_unit_amount = self.get_buy_unit_amount()
            while trade_unit_amount > 0 and not self.exchange.has_enough_unused_fiat_money(status.now_buy_fiat_price * status.trade_unit * trade_unit_amount, status.unused_fiat_money):
                trade_unit_amount >>= 1
            if trade_unit_amount > 0:
                please_buy_unit_amount = trade_unit_amount

        if self.exchange.is_trade_fiat_money_larger_than_limit(
            status.crypto_symbol,
            status.fiat_symbol,
            status.trade_unit * please_buy_unit_amount,
            status.now_buy_fiat_price_without_fee
        ):
            self.buy(please_buy_unit_amount)
            status.sample_number = 0
            return type(self).SAMPLE_INTERVAL, 'buy', please_buy_unit_amount

        return type(self).SAMPLE_INTERVAL, 'wait', 0

# Cell
import os
import requests


class Notifier(object):

    def __init__(self, channel_name='general', name='!!', icon_url='https://jupyter.org/assets/apple-touch-icon.png'):
        self.webhook_url = os.environ['SLACK_WEBHOOK_URL']

        self.good_channel_id = os.environ[f'SLACK_GOOD_{channel_name.upper()}_CHANNEL_ID']
        self.danger_channel_id = os.environ[f'SLACK_DANGER_{channel_name.upper()}_CHANNEL_ID']

        self.name = name
        self.icon_url = icon_url

    def send_slack(self, message, text, color='good'):
        if color == 'good':
            channel_id = self.good_channel_id
            message = f':grinning: {message}'
        if color == 'danger':
            channel_id = self.danger_channel_id
            message = f':slightly_frowning_face: {message}'

        requests.post(
            self.webhook_url,
            json={
                'channel': channel_id,
                'username': f'{self.name} Notifications',
                'icon_url': self.icon_url,
                'text': message,
                'mrkdwn': True,
                'attachments': [{
                    'title': '→ Trading Operations',
                    'title_link': 'https://jhub.name/user/sheng_wei/lab',
                    'text': text,
                    'color': color,
                }]
            }
        )