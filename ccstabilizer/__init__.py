# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/notifier.ipynb (unless otherwise specified).

__all__ = ['Exchange', 'Binance', 'BinanceAPI', 'Bitbank', 'Huobi', 'HuobiSVC', 'MXC', 'MXCAPI', 'Status', 'Fetcher',
           'Portfolio', 'BookKeeper', 'Trader', 'Notifier']

# Cell
class Exchange(object):

    def __init__(self):
        self.trading_specifications = {}

    def get_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.trading_specifications.get((crypto_symbol, fiat_symbol), {})

    def get_portfolio(self):
        raise NotImplementedError

    def get_price(self, crypto_symbol, fiat_symbol):
        raise NotImplementedError

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        raise NotImplementedError

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        raise NotImplementedError

# Cell
from decimal import Decimal


class Binance(Exchange):

    def __init__(self):
        super().__init__()
        self.binance = BinanceAPI(os.environ['BINANCE_API_KEY'], os.environ['BINANCE_API_SECRET'])
        for symbol_info in self.binance.exchangeInfo().get('symbols', []):
            symbol = symbol_info.get('symbol', '')
            trading_spec = {}
            for binance_filter in symbol_info.get('filters', []):
                if binance_filter.get('filterType', '') == 'LOT_SIZE':
                    trading_spec['min_trade_unit'] = Decimal(binance_filter.get('stepSize', '0.0001'))
                    break
            for binance_filter in symbol_info.get('filters', []):
                if binance_filter.get('filterType', '') == 'MIN_NOTIONAL':
                    trading_spec['min_trade_fiat_money_limit'] = Decimal(binance_filter.get('minNotional', '0'))
                    break
            trading_spec['fee_rate'] = Decimal('0.001')
            if 'permissions' in symbol_info:
                trading_spec['liquid'] = 'SPOT' in symbol_info.get('permissions', [])
            self.trading_specifications[symbol] = trading_spec

    def get_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.trading_specifications.get(f'{crypto_symbol}{fiat_symbol}', {})

    def get_portfolio(self):
        return {
            asset.get('asset', ''): Decimal(asset.get('free', '0')) for asset in self.binance.account().get('balances', [])
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        avg_price = self.binance.avgPrice(symbol=f'{crypto_symbol}{fiat_symbol}')
        if 'price' in avg_price:
            self.get_trading_specification(crypto_symbol, fiat_symbol)['average_fiat_price'] = Decimal(avg_price.get('price', '0'))
        now_ticker = self.binance.tickerBookTicker(symbol=f'{crypto_symbol}{fiat_symbol}')
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('askPrice', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('bidPrice', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee / (1 - fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee=None):
        if amount <= 0:
            raise Exception('Binance::buy  amount <= 0')
        self.binance.createOrder(
            symbol=f'{crypto_symbol}{fiat_symbol}', side='BUY', type='MARKET', quantity=str(amount), recvWindow=5000
        )

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee=None):
        if amount <= 0:
            raise Exception('Binance::sell  amount <= 0')
        self.binance.createOrder(
            symbol=f'{crypto_symbol}{fiat_symbol}', side='SELL', type='MARKET', quantity=str(amount), recvWindow=5000
        )

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money

    def trade_fiat_money_is_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee=None):
        # Just for Binance
        average_fiat_price = self.get_trading_specification(crypto_symbol, fiat_symbol).get('average_fiat_price', 0)
        return average_fiat_price * amount > self.get_trading_specification(crypto_symbol, fiat_symbol).get('min_trade_fiat_money_limit', 0)

# Cell
# Credits to @Bablofil https://github.com/Bablofil/binance-api
import contextlib
import time
import json
import urllib
import hmac, hashlib
import requests

from urllib.parse import urlparse, urlencode
from urllib.request import Request, urlopen

class BinanceAPI(object):

    methods = {
        #  Public methods
        'ping':             {'url': 'ping', 'method': 'GET', 'private': False},
        'time':             {'url': 'time', 'method': 'GET', 'private': False},
        'exchangeInfo':     {'url': 'exchangeInfo', 'method': 'GET', 'private': False},
        'depth':            {'url': 'depth', 'method': 'GET', 'private': False},
        'trades':           {'url': 'trades', 'method': 'GET', 'private': False},
        'historicalTrades': {'url': 'historicalTrades', 'method': 'GET', 'private': False},
        'aggTrades':        {'url': 'aggTrades', 'method': 'GET', 'private': False},
        'klines':           {'url': 'klines', 'method': 'GET', 'private': False},
        'avgPrice':         {'url': 'avgPrice', 'method': 'GET', 'private': False},
        'ticker24hr':       {'url': 'ticker/24hr', 'method': 'GET', 'private': False},
        'tickerPrice':      {'url': 'ticker/price', 'method': 'GET', 'private': False},
        'tickerBookTicker': {'url': 'ticker/bookTicker', 'method': 'GET', 'private': False},
        #  Private methods
        'createOrder':      {'url': 'order', 'method': 'POST', 'private': True},
        'testOrder':        {'url': 'test', 'method': 'POST', 'private': True},
        'orderInfo':        {'url': 'order', 'method': 'GET', 'private': True},
        'cancelOrder':      {'url': 'order', 'method': 'DELETE', 'private': True},
        'openOrders':       {'url': 'openOrders', 'method': 'GET', 'private': True},
        'allOrders':        {'url': 'allOrders', 'method': 'GET', 'private': True},
        'account':          {'url': 'account', 'method': 'GET', 'private': True},
        'myTrades':         {'url': 'myTrades', 'method': 'GET', 'private': True},
    }

    RETRY_INTERVAL = 60

    def __init__(self, API_KEY, API_SECRET):
        self.API_KEY = API_KEY
        self.API_SECRET = bytearray(API_SECRET, encoding='utf-8')
        self.shift_seconds = 0

    def __getattr__(self, name):
        def wrapper(*args, **kwargs):
            kwargs.update(command=name)

            while True:
                try:
                    return self.call_api(**kwargs)
                except Exception as e:
                    print(e)
                    Notifier(channel_name='binance', name='API ERROR').send_slack(
                        e, 'Power by https://jhub.name/', 'good'
                    )
                    raise
                    time.sleep(type(self).RETRY_INTERVAL)

        return wrapper

    def set_shift_seconds(self, seconds):
        self.shift_seconds = seconds

    def call_api(self, **kwargs):

        command = kwargs.pop('command')
        api_url = 'https://api.binance.com/api/v3/' + self.methods[command]['url']

        payload = kwargs
        headers = {}

        payload_str = urllib.parse.urlencode(payload)
        if self.methods[command]['private']:
            payload.update({'timestamp': int(time.time() + self.shift_seconds - 1) * 1000})
            payload_str = urllib.parse.urlencode(payload).encode('utf-8')
            sign = hmac.new(
                key=self.API_SECRET,
                msg=payload_str,
                digestmod=hashlib.sha256
            ).hexdigest()

            payload_str = payload_str.decode("utf-8") + "&signature="+str(sign)
            headers = {"X-MBX-APIKEY": self.API_KEY}

        if self.methods[command]['method'] == 'GET':
            api_url += '?' + payload_str

        with contextlib.closing(
            requests.request(
                method=self.methods[command]['method'], url=api_url, headers=headers,
                data='' if self.methods[command]['method'] == 'GET' else payload_str
            )
        ) as response:
            response_json = response.json()
            if 'code' in response_json:
                # ex. response_json
                # {"code":-1021,"msg":"Timestamp for this request is outside of the recvWindow."}
                raise Exception(
                    f'{response_json.get("msg", "")}\n'
                    f'kwargs={kwargs}'
                )
            return response_json

# Cell
import contextlib, requests
from decimal import Decimal

import python_bitbankcc


class Bitbank(Exchange):

    def __init__(self):
        super().__init__()
        self.pub = python_bitbankcc.public()
        self.prv = python_bitbankcc.private(
            os.environ['BITBANK_API_KEY'],
            os.environ['BITBANK_API_SECRET']
        )
        self.update_trading_specifications()

    def update_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.update_trading_specifications().get((crypto_symbol, fiat_symbol), {})

    def update_trading_specifications(self):
        with contextlib.closing(requests.get('https://api.bitbank.cc/v1/spot/status')) as response:
            specs = response.json().get('data', {}).get('statuses', [])
        for spec in specs:
            crypto_symbol, fiat_symbol = spec.get('pair', '_').split('_')
            crypto_symbol, fiat_symbol = crypto_symbol.upper(), fiat_symbol.upper()
            trading_spec = self.trading_specifications.setdefault((crypto_symbol, fiat_symbol), {})
            if 'min_amount' in spec:
                trading_spec['min_trade_unit'] = Decimal(spec.get('min_amount', '0.0001'))
        with contextlib.closing(requests.get('https://api.bitbank.cc/v1/spot/pairs')) as response:
            specs = response.json().get('data', {}).get('pairs', [])
        for spec in specs:
            crypto_symbol, fiat_symbol = spec.get('name', '_').split('_')
            crypto_symbol, fiat_symbol = crypto_symbol.upper(), fiat_symbol.upper()
            trading_spec = self.trading_specifications.setdefault((crypto_symbol, fiat_symbol), {})
            if 'taker_fee_rate_quote' in spec:
                trading_spec['fee_rate'] = Decimal(spec.get('taker_fee_rate_quote', '0.0012'))
            if 'is_enabled' in spec:
                trading_spec['liquid'] = spec.get('is_enabled', False)
        return self.trading_specifications

    def get_portfolio(self):
        return {
            asset.get('asset', '').upper(): Decimal(asset.get('free_amount', '0')) for asset in self.prv.get_asset().get('assets', [])
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        now_ticker = self.pub.get_ticker(f'{crypto_symbol.lower()}_{fiat_symbol.lower()}')
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('sell', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('buy', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 + fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('Bitbank::buy  amount <= 0')
        self.prv.order(
            pair=f'{crypto_symbol.lower()}_{fiat_symbol.lower()}', price=str(fiat_price_without_fee),
            amount=str(amount), side='buy', order_type='market'
        )

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('Bitbank::sell  amount <= 0')
        self.prv.order(
            pair=f'{crypto_symbol.lower()}_{fiat_symbol.lower()}', price=str(fiat_price_without_fee),
            amount=str(amount), side='sell', order_type='market'
        )

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money * Decimal('0.75')

    def trade_fiat_money_is_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        return amount > 0

# Cell
import contextlib, requests
from decimal import Decimal, ROUND_DOWN


class Huobi(Exchange):

    def __init__(self):
        super().__init__()
        self.huobi = HuobiSVC(os.environ['HUOBI_API_ACCESS_KEY'], os.environ['HUOBI_API_SECRET_KEY'])
        self.account_id = self.huobi.get_accounts()['data'][0]['id']
        self.update_trading_specifications()

    def update_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.update_trading_specifications().get((crypto_symbol, fiat_symbol), {})

    def update_trading_specifications(self):
        specs = self.huobi.get_symbols()['data']
        for spec in specs:
            crypto_symbol, fiat_symbol = spec.get('base-currency', '').upper(), spec.get('quote-currency', '').upper()
            trading_spec = self.trading_specifications.setdefault((crypto_symbol, fiat_symbol), {})
            trading_spec['min_trade_unit'] = max(
                Decimal(repr(spec.get('limit-order-min-order-amt', 0.0001))),
                Decimal(repr(spec.get('sell-market-min-order-amt', 0.0001))),
                Decimal('0.1') ** Decimal(repr(spec.get('amount-precision', 0))),
            )
            trading_spec['min_trade_fiat_money_limit'] = Decimal(repr(spec.get('min-order-value', 1)))
            trading_spec['fee_rate'] = Decimal('0.002')
            trading_spec['liquid'] = spec.get('api-trading', 'disabled') == 'enabled'
        return self.trading_specifications

    def get_portfolio(self):
        return {
            asset['currency'].upper(): Decimal(asset.get('balance', '0')) for asset in self.huobi.get_balance(**{'account-id': self.account_id})['data']['list'] \
                if asset['type'] == 'trade' and Decimal(asset.get('balance', '0')) > 0
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        now_ticker = self.huobi.get_ticker(symbol=f'{crypto_symbol.lower()}{fiat_symbol.lower()}')['tick']
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('ask', ['Infinity', '0'])[0])
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('bid', ['0', '0'])[0])
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee / (1 - fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('Huobi::buy  amount <= 0')
        fiat_money = (fiat_price_without_fee * amount).quantize(Decimal('1.00'), ROUND_DOWN)
        self.huobi.send_order(
            **{'account-id': self.account_id, 'symbol': f'{crypto_symbol.lower()}{fiat_symbol.lower()}', 'type': 'buy-market', 'amount': str(fiat_money)}
        )

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('Huobi::sell  amount <= 0')
        self.huobi.send_order(
            **{'account-id': self.account_id, 'symbol': f'{crypto_symbol.lower()}{fiat_symbol.lower()}', 'type': 'sell-market', 'amount': str(amount)}
        )

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money

    def trade_fiat_money_is_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        return fiat_price_without_fee * amount > self.get_trading_specification(crypto_symbol, fiat_symbol).get('min_trade_fiat_money_limit', 0)

# Cell
import base64
import contextlib
import hashlib
import hmac
import json
import urllib
import urllib.parse
import urllib.request
import requests

from datetime import datetime


class HuobiSVC(object):

    methods = {
        # Public methods
        'get_kline':           {'url': 'market/history/kline', 'method': 'GET', 'private': False},
        'get_depth':           {'url': 'market/depth', 'method': 'GET', 'private': False},
        'get_trade':           {'url': 'market/trade', 'method': 'GET', 'private': False},
        'get_tickers':         {'url': 'market/tickers', 'method': 'GET', 'private': False},
        'get_ticker':          {'url': 'market/detail/merged', 'method': 'GET', 'private': False},
        'get_detail':          {'url': 'market/detail', 'method': 'GET', 'private': False},
        'get_symbols':         {'url': 'v1/common/symbols', 'method': 'GET', 'private': False},
        'get_currencies':      {'url': 'v1/common/currencys', 'method': 'GET', 'private': False},
        # Private methods
        'get_accounts':        {'url': 'v1/account/accounts', 'method': 'GET', 'private': True},
        'get_balance':         {'url': 'v1/account/accounts/{account-id}/balance', 'method': 'GET', 'private': True},
        'send_order':          {'url': 'v1/order/orders/place', 'method': 'POST', 'private': True},
        'cancel_order':        {'url': 'v1/order/orders/{order-id}/submitcancel', 'method': 'POST', 'private': True},
        'order_info':          {'url': 'v1/order/orders/{order-id}', 'method': 'GET', 'private': True},
        'order_matchresults':  {'url': 'v1/order/orders/{order-id}/matchresults', 'method': 'GET', 'private': True},
        'orders_list':         {'url': 'v1/order/orders', 'method': 'GET', 'private': True},
        'orders_matchresults': {'url': 'v1/order/matchresults', 'method': 'GET', 'private': True},
        'open_orders':         {'url': 'v1/order/openOrders', 'method': 'GET', 'private': True},
        'cancel_open_orders':  {'url': 'v1/order/orders/batchCancelOpenOrders', 'method': 'POST', 'private': True},
        'withdraw':            {'url': 'v1/dw/withdraw/api/create', 'method': 'POST', 'private': True},
        'cancel_withdraw':     {'url': 'v1/dw/withdraw-virtual/{withdraw-id}/cancel', 'method': 'POST', 'private': True},
    }

    RETRY_INTERVAL = 60

    def __init__(self, access_key, secret_key):
        self.access_key = access_key
        self.secret_key = secret_key
        self.base_url = 'https://api-aws.huobi.pro/'

    def __getattr__(self, command):
        def call_api(**kwargs):

            while True:
                try:

                    url = self.base_url + type(self).methods[command]['url'].format(**kwargs)

                    payload = kwargs
                    headers = {}

                    payload_str = urllib.parse.urlencode(payload)
                    if self.methods[command]['private']:
                        if self.methods[command]['method'] == 'GET':
                            return self.api_key_get(url, **kwargs)
                        else:
                            return self.api_key_post(url, **kwargs)
                    else:
                        if self.methods[command]['method'] == 'GET':
                            return self.http_get_request(url, **kwargs)

                except Exception as e:
                    raise
                    time.sleep(type(self).RETRY_INTERVAL)

        return call_api

    def http_get_request(self, url, add_to_headers=None, **params):
        headers = {
            'Content-type': 'application/x-www-form-urlencoded',
            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
        }
        if add_to_headers:
            headers.update(add_to_headers)
        postdata = urllib.parse.urlencode(params)
        with contextlib.closing(
            requests.get(url, postdata, headers=headers, timeout=5)
        ) as response:
            try:
                response_json = response.json()
                if response_json['status'] == 'ok':
                    return response_json
                else:
                    raise Exception('status == error')
            except BaseException as e:
                print(f'httpGet failed, detail: {response.text}, {e}')
                print(f'url = {url}')
                print(f'params = {params}')
                raise

    def http_post_request(self, url, add_to_headers=None, **params):
        headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        }
        if add_to_headers:
            headers.update(add_to_headers)
        postdata = json.dumps(params)
        with contextlib.closing(
            requests.post(url, postdata, headers=headers, timeout=10)
        ) as response:
            try:
                response_json = response.json()
                if response_json['status'] == 'ok':
                    return response_json
                else:
                    raise Exception('status == error')
            except BaseException as e:
                print(f'httpPost failed, detail: {response.text}, {e}')
                print(f'url = {url}')
                print(f'params = {params}')
                raise

    def api_key_get(self, url, **params):
        method = 'GET'
        timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S')
        params.update({'AccessKeyId': self.access_key,
                       'SignatureMethod': 'HmacSHA256',
                       'SignatureVersion': '2',
                       'Timestamp': timestamp})

        host_name = urllib.parse.urlparse(url).hostname
        host_name = host_name.lower()
        request_path = urllib.parse.urlparse(url).path
        params['Signature'] = self.createSign(params, method, host_name, request_path, self.secret_key)

        return self.http_get_request(url, **params)

    def api_key_post(self, url, **params):
        method = 'POST'
        timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S')
        params_to_sign = {'AccessKeyId': self.access_key,
                          'SignatureMethod': 'HmacSHA256',
                          'SignatureVersion': '2',
                          'Timestamp': timestamp}

        host_name = urllib.parse.urlparse(url).hostname
        host_name = host_name.lower()
        request_path = urllib.parse.urlparse(url).path
        params_to_sign['Signature'] = self.createSign(params_to_sign, method, host_name, request_path, self.secret_key)
        url += '?' + urllib.parse.urlencode(params_to_sign)
        return self.http_post_request(url, **params)

    def createSign(self, pParams, method, host_url, request_path, secret_key):
        sorted_params = sorted(pParams.items(), key=lambda d: d[0], reverse=False)
        encode_params = urllib.parse.urlencode(sorted_params)
        payload = [method, host_url, request_path, encode_params]
        payload = '\n'.join(payload)
        payload = payload.encode(encoding='UTF8')
        secret_key = secret_key.encode(encoding='UTF8')

        digest = hmac.new(secret_key, payload, digestmod=hashlib.sha256).digest()
        signature = base64.b64encode(digest)
        signature = signature.decode()
        return signature

    # get KLine
#     def get_kline(self, symbol, period, size=150):
#         """
#         :param symbol: btcusdt, ethbtc, ...
#         :param period: 可选值：{1min, 5min, 15min, 30min, 60min, 1day, 1mon, 1week, 1year }
#         :param size: 可选值： [1,2000]
#         :return:
#         """
#         params = {'symbol': symbol,
#                   'period': period,
#                   'size': size}

#         url = self.market_url + '/market/history/kline'
#         return self.http_get_request(url, params)

    # get market prices
    def get_kline_df(self, symbol, period, size):
        res = self.get_kline(symbol=symbol, period=period, size=size)
        if res['status'] == 'ok':
            import pandas as pd
            kline_df = pd.DataFrame(res['data'])
            return kline_df
        else:
            raise Exception('Query failed with status: {}'.format(res))

    # get market depth
#     def get_depth(self, symbol, type):
#         """
#         :param symbol
#         :param type: 可选值：{ percent10, step0, step1, step2, step3, step4, step5 }
#         :return:
#         """
#         params = {'symbol': symbol,
#                   'type': type}

#         url = self.market_url + '/market/depth'
#         return self.http_get_request(url, params)

    # get trade detail
#     def get_trade(self, symbol):
#         """
#         :param symbol
#         :return:
#         """
#         params = {'symbol': symbol}

#         url = self.market_url + '/market/trade'
#         return self.http_get_request(url, params)

    # Tickers detail
#     def get_tickers(self):
#         """
#         :return:
#         """
#         params = {}
#         url = self.market_url + '/market/tickers'
#         return self.http_get_request(url, params)

    # get merge ticker
#     def get_ticker(self, symbol):
#         """
#         :param symbol:
#         :return:
#         """
#         params = {'symbol': symbol}

#         url = self.market_url + '/market/detail/merged'
#         return self.http_get_request(url, params)

    # get Market Detail 24 hour volume
#     def get_detail(self, symbol):
#         """
#         :param symbol
#         :return:
#         """
#         params = {'symbol': symbol}

#         url = self.market_url + '/market/detail'
#         return self.http_get_request(url, params)

    # get available symbols
#     def get_symbols(self, long_polling=None):
#         """
#         """
#         params = {}
#         if long_polling:
#             params['long-polling'] = long_polling
#         path = '/v1/common/symbols'
#         return self.api_key_get(params, path)

    # Get available currencies
#     def get_currencies(self):
#         """
#         :return:
#         """
#         params = {}
#         url = self.market_url + '/v1/common/currencys'

#         return self.http_get_request(url, params)

    # Get all the trading assets
#     def get_trading_assets(self):
#         """
#         :return:
#         """
#         params = {}
#         url = self.market_url + '/v1/common/symbols'

#         return self.http_get_request(url, params)

    """
    Trade/Account API
    """

#     def get_accounts(self):
#         """
#         :return:
#         """
#         path = "/v1/account/accounts"
#         params = {}
#         return self.api_key_get(params, path)

    # get account balance
#     def get_balance(self, account_id=None):
#         """
#         :param account_id
#         :return:
#         """

#         if account_id is None:
#             accounts = self.get_accounts()
#             account_id = accounts['data'][0]['id']

#         url = f'{self.base_url}v1/account/accounts/{account_id}/balance'
#         params = {'account-id': account_id}
#         return self.api_key_get(url, **params)

    # get balance for a currency
    def get_balance_currency(self, account_id, symbol):
        res = self.get_balance(account_id=account_id)
        if res['status'] == 'ok':
            res_dict = {}
            import pandas as pd
            balance_df = pd.DataFrame(res['data']['list'])
            res_df = balance_df[balance_df['currency'] == symbol]
            res_dict['trade_balance'] = float(res_df[res_df['type'] == 'trade']['balance'].values[0])
            res_dict['frozen_balance'] = float(res_df[res_df['type'] == 'frozen']['balance'].values[0])
            return res_dict
        else:
            raise Exception('Query failed with status -> {}'.format(res['status']))

    # Making Orders
#     def send_order(self, acct_id, amount, source, symbol, _type, price=0, stop_price=0, operator=None):
#         """
#         :param acct_id: account id
#         :param amount:
#         :param source: 如果使用借贷资产交易，请在下单接口的请求参数source中填写'margin-api'
#         :param symbol:
#         :param _type: options {buy-market：市价买, sell-market：市价卖, buy-limit：限价买, sell-limit：限价卖}
#         :param price:
#         :param stop_price:
#         :param operator: gte – greater than and equal (>=), lte – less than and equal (<=)
#         :return:
#         """

#         params = {"account-id": acct_id,
#                   "amount": amount,
#                   "symbol": symbol,
#                   "type": _type,
#                   "source": source}
#         if price:
#             params["price"] = price
#         if stop_price:
#             params["stop-price"] = stop_price
#         if operator:
#             params["operator"] = operator

#         url = '/v1/order/orders/place'
#         return self.api_key_post(params, url)

    # cancel an order
#     def cancel_order(self, order_id):
#         """
#         :param order_id:
#         :return:
#         """
#         params = {}
#         url = f'{self.base_url}v1/order/orders/{order_id}/submitcancel'
#         return self.api_key_post(url, **params)

    # get an order info
#     def order_info(self, order_id):
#         """
#         :param order_id:
#         :return:
#         """
#         params = {}
#         url = f'{self.base_url}v1/order/orders/{order_id}'
#         return self.api_key_get(url, **params)

    # get order results
#     def order_matchresults(self, order_id):
#         """
#         :param order_id:
#         :return:
#         """
#         params = {}
#         url = f'{self.base_url}v1/order/orders/{order_id}/matchresults'
#         return self.api_key_get(url, **params)

    # get order list
#     def orders_list(self, symbol, states, types=None, start_date=None, end_date=None, _from=None, direct=None, size=None):
#         """
#         :param symbol:
#         :param states: options {pre-submitted 准备提交, submitted 已提交, partial-filled 部分成交, partial-canceled 部分成交撤销, filled 完全成交, canceled 已撤销}
#         :param types: options {buy-market：市价买, sell-market：市价卖, buy-limit：限价买, sell-limit：限价卖}
#         :param start_date:
#         :param end_date:
#         :param _from:
#         :param direct: options {prev 向前，next 向后}
#         :param size:
#         :return:
#         """
#         params = {'symbol': symbol,
#                   'states': states}

#         if types:
#             params['types'] = types
#         if start_date:
#             params['start-date'] = start_date
#         if end_date:
#             params['end-date'] = end_date
#         if _from:
#             params['from'] = _from
#         if direct:
#             params['direct'] = direct
#         if size:
#             params['size'] = size
#         url = '/v1/order/orders'
#         return self.api_key_get(params, url)

    # get matched orders
#     def orders_matchresults(self, symbol, types=None, start_date=None, end_date=None, _from=None, direct=None, size=None):
#         """
#         :param symbol:
#         :param types: options {buy-market：市价买, sell-market：市价卖, buy-limit：限价买, sell-limit：限价卖}
#         :param start_date:
#         :param end_date:
#         :param _from:
#         :param direct: options {prev 向前，next 向后}
#         :param size:
#         :return:
#         """
#         params = {'symbol': symbol}

#         if types:
#             params['types'] = types
#         if start_date:
#             params['start-date'] = start_date
#         if end_date:
#             params['end-date'] = end_date
#         if _from:
#             params['from'] = _from
#         if direct:
#             params['direct'] = direct
#         if size:
#             params['size'] = size
#         url = '/v1/order/matchresults'
#         return self.api_key_get(params, url)

    # get open orders
#     def open_orders(self, account_id, symbol, side='', size=10):
#         """
#         :param symbol:
#         :return:
#         """
#         params = {}
#         url = "/v1/order/openOrders"
#         if symbol:
#             params['symbol'] = symbol
#         if account_id:
#             params['account-id'] = account_id
#         if side:
#             params['side'] = side
#         if size:
#             params['size'] = size

#         return self.api_key_get(params, url)

    # batch cancel orders
#     def cancel_open_orders(self, account_id, symbol, side='', size=10):
#         """
#         :param symbol:
#         :return:
#         """
#         params = {}
#         url = "/v1/order/orders/batchCancelOpenOrders"
#         if symbol:
#             params['symbol'] = symbol
#         if account_id:
#             params['account-id'] = account_id
#         if side:
#             params['side'] = side
#         if size:
#             params['size'] = size

#         return self.api_key_post(params, url)

    # withdraw currencies
#     def withdraw(self, address, amount, currency, fee=0, addr_tag=""):
#         """
#         :param address_id:
#         :param amount:
#         :param currency:btc, ltc, bcc, eth, etc ...(火币Pro支持的币种)
#         :param fee:
#         :param addr-tag:
#         :return: {
#                   "status": "ok",
#                   "data": 700
#                 }
#         """
#         params = {'address': address,
#                   'amount': amount,
#                   "currency": currency,
#                   "fee": fee,
#                   "addr-tag": addr_tag}
#         url = '/v1/dw/withdraw/api/create'

#         return self.api_key_post(params, url)

    # cancel withdraw order
#     def cancel_withdraw(self, address_id):
#         """
#         :param address_id:
#         :return: {
#                   "status": "ok",
#                   "data": 700
#                 }
#         """
#         params = {}
#         url = '/v1/dw/withdraw-virtual/{0}/cancel'.format(address_id)

#         return self.api_key_post(params, url)

    """
    MARGIN API
    """

    # create and send margin order
#     def send_margin_order(self, account_id, amount, symbol, _type, price=0):
#         """
#         :param account_id:
#         :param amount:
#         :param symbol:
#         :param _type: options {buy-market：市价买, sell-market：市价卖, buy-limit：限价买, sell-limit：限价卖}
#         :param price:
#         :return:
#         """
#         try:
#             accounts = self.get_accounts()
#             acct_id = accounts['data'][0]['id']
#         except BaseException as e:
#             print('get acct_id error.%s' % e)
#             acct_id = account_id

#         params = {"account-id": acct_id,
#                   "amount": amount,
#                   "symbol": symbol,
#                   "type": _type,
#                   "source": 'margin-api'}
#         if price:
#             params["price"] = price

#         url = '/v1/order/orders/place'
#         return self.api_key_post(params, url)

    # exchange account to margin account
#     def exchange_to_margin(self, symbol, currency, amount):
#         """
#         :param amount:
#         :param currency:
#         :param symbol:
#         :return:
#         """
#         params = {"symbol": symbol,
#                   "currency": currency,
#                   "amount": amount}

#         url = "/v1/dw/transfer-in/margin"
#         return self.api_key_post(params, url)

    # margin account to exchange account
#     def margin_to_exchange(self, symbol, currency, amount):
#         """
#         :param amount:
#         :param currency:
#         :param symbol:
#         :return:
#         """
#         params = {"symbol": symbol,
#                   "currency": currency,
#                   "amount": amount}

#         url = "/v1/dw/transfer-out/margin"
#         return self.api_key_post(params, url)

    # get margin
#     def get_margin(self, symbol, currency, amount):
#         """
#         :param amount:
#         :param currency:
#         :param symbol:
#         :return:
#         """
#         params = {"symbol": symbol,
#                   "currency": currency,
#                   "amount": amount}
#         url = "/v1/margin/orders"
#         return self.api_key_post(params, url)

    # repay
#     def repay_margin(self, order_id, amount):
#         """
#         :param order_id:
#         :param amount:
#         :return:
#         """
#         params = {"order-id": order_id,
#                   "amount": amount}
#         url = "/v1/margin/orders/{0}/repay".format(order_id)
#         return self.api_key_post(params, url)

    # loan order
#     def loan_orders(self, symbol, currency, start_date="", end_date="", start="", direct="", size=""):
#         """
#         :param symbol:
#         :param currency:
#         :param direct: prev 向前，next 向后
#         :return:
#         """
#         params = {"symbol": symbol,
#                   "currency": currency}
#         if start_date:
#             params["start-date"] = start_date
#         if end_date:
#             params["end-date"] = end_date
#         if start:
#             params["from"] = start
#         if direct and direct in ["prev", "next"]:
#             params["direct"] = direct
#         if size:
#             params["size"] = size
#         url = "/v1/margin/loan-orders"
#         return self.api_key_get(params, url)

    # get margin balance
#     def margin_balance(self, symbol):
#         """
#         :param symbol:
#         :return:
#         """
#         params = {}
#         url = "/v1/margin/accounts/balance"
#         if symbol:
#             params['symbol'] = symbol

#         return self.api_key_get(params, url)

#     def margin_loan_info(self, symbol):
#         """
#         :param symbol:
#         :return:
#         """
#         params = {}
#         url = "/v1/margin/loan-info"
#         if symbol:
#             params['symbol'] = symbol
#         return self.api_key_get(params, url)

# Cell
from decimal import Decimal


class MXC(Exchange):

    def __init__(self):
        super().__init__()
        self.mxc = MXCAPI(os.environ['MXC_ACCESS_KEY'], os.environ['MXC_SECRET_KEY'])
        self.update_trading_specifications()

    def update_trading_specification(self, crypto_symbol, fiat_symbol):
        return self.update_trading_specifications().get((crypto_symbol, fiat_symbol), {})

    def update_trading_specifications(self):
        for symbol_info in self.mxc.get_symbols():
            crypto_symbol, fiat_symbol = symbol_info.get('symbol', '').split('_')
            trading_spec = {}
            if 'quantity_scale' in symbol_info:
                trading_spec['min_trade_unit'] = Decimal('0.1') ** symbol_info.get('quantity_scale', 0)
            if 'min_amount' in symbol_info:
                trading_spec['min_trade_fiat_money_limit'] = Decimal(symbol_info.get('min_amount', '0'))
            if 'maker_fee_rate' in symbol_info:
                trading_spec['fee_rate'] = Decimal(symbol_info.get('maker_fee_rate', '0'))
            if 'limited' in symbol_info:
                trading_spec['liquid'] = symbol_info.get('limited', False)
            self.trading_specifications[(crypto_symbol, fiat_symbol)] = trading_spec
        self.get_trading_specification('XPX', 'USDT')['min_trade_fiat_money_limit'] *= 4
        return self.trading_specifications

    def get_portfolio(self):
        return {
            symbol: Decimal(asset.get('available', '0')) for symbol, asset in self.mxc.get_account_info().items()
        }

    def get_price(self, crypto_symbol, fiat_symbol):
        now_ticker = self.mxc.get_ticker(f'{crypto_symbol}_{fiat_symbol}')[0]
        now_buy_fiat_price_without_fee = Decimal(now_ticker.get('ask', 'Infinity'))
        now_sell_fiat_price_without_fee = Decimal(now_ticker.get('bid', '0'))
        fee_rate = self.get_trading_specification(crypto_symbol, fiat_symbol).get('fee_rate', 0)
        return {
            'now_buy_fiat_price': self.get_buy_fiat_price(now_buy_fiat_price_without_fee, fee_rate),
            'now_sell_fiat_price': self.get_sell_fiat_price(now_sell_fiat_price_without_fee, fee_rate),
            'now_buy_fiat_price_without_fee': now_buy_fiat_price_without_fee,
            'now_sell_fiat_price_without_fee': now_sell_fiat_price_without_fee,
        }

    def get_buy_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 + fee_rate)

    def get_sell_fiat_price(self, fiat_price_without_fee, fee_rate):
        return fiat_price_without_fee * (1 - fee_rate)

    def buy(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('MXC::buy  amount <= 0')
        self.mxc.place_order(f'{crypto_symbol}_{fiat_symbol}', str(fiat_price_without_fee), str(amount), 'BID', 'IMMEDIATE_OR_CANCEL')

    def sell(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        if amount <= 0:
            raise Exception('MXC::sell  amount <= 0')
        self.mxc.place_order(f'{crypto_symbol}_{fiat_symbol}', str(fiat_price_without_fee), str(amount), 'ASK', 'IMMEDIATE_OR_CANCEL')

    def has_enough_unused_fiat_money(self, buy_fiat_money, unused_fiat_money):
        return buy_fiat_money <= unused_fiat_money

    def trade_fiat_money_is_larger_than_limit(self, crypto_symbol, fiat_symbol, amount, fiat_price_without_fee):
        # Just for MXC
        return fiat_price_without_fee * amount > self.get_trading_specification(crypto_symbol, fiat_symbol).get('min_trade_fiat_money_limit', 0)

# Cell
import contextlib
import hashlib
import hmac
import os
import requests
import time

from urllib import parse


class MXCAPI(object):

    ROOT_URL = 'https://www.mxc.ceo'
    ERROR_MESSAGES = {
        400: '请求参数无效。',
        401: '签名验证失败。',
        429: '请求过于频繁。',
        10072: '无效的 Access Key。',
        10073: '无效的请求时间。',
        30000: '当前交易对已暂停交易。',
        30001: '当前交易方向不允许下单。',
        30002: '小于最小交易金额。',
        30003: '大于最大交易金额。',
        30004: '持仓不足。',
        30005: '卖出超额。',
        30010: '下单价格超过范围。',
        30016: '暂停交易。',
        30019: '订单集合超出最大允许长度。',
        30020: '受限制的交易对，暂不支持 API 访问。',
        30021: '无效的交易对。',
    }

    def __init__(self, API_KEY, SECRET_KEY):
        self.API_KEY = API_KEY
        self.SECRET_KEY = SECRET_KEY

    @staticmethod
    def _get_server_time():
        return int(time.time())

    def _sign(self, method, path, original_params=None):
        params = {
            'api_key': self.API_KEY,
            'req_time': type(self)._get_server_time(),
        }
        if original_params is not None:
            params.update(original_params)
        params_str = '&'.join('{}={}'.format(k, params[k]) for k in sorted(params))
        to_sign = '\n'.join([method, path, params_str])
        params.update({
            'sign': hmac.new(self.SECRET_KEY.encode(), to_sign.encode(), hashlib.sha256).hexdigest()
        })
        return params

    def _request(self, method, path, params):
        url = '{}{}'.format(type(self).ROOT_URL, path)
        with contextlib.closing(
            requests.request(method, url, params=params)
        ) as response:
            response_json = response.json()
            code = response_json.get('code', 0)
            if code != 200:
                raise Exception(
                    f'{type(self).ERROR_MESSAGES.get(code, response_json.get("msg", "未知错误。"))}\n'
                    f'path={path}\n'
                    f'params={params}\n'
                )
            return response_json.get('data', {})

    def get_symbols(self):
        """marget data"""
        method = 'GET'
        path = '/open/api/v2/market/symbols'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_rate_limit(self):
        """rate limit"""
        method = 'GET'
        path = '/open/api/v2/common/rate_limit'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_timestamp(self):
        """get current time"""
        method = 'GET'
        path = '/open/api/v2/common/timestamp'
        params = {'api_key': self.API_KEY}
        return self._request(method, path, params)

    def get_ticker(self, symbol):
        """get ticker information"""
        method = 'GET'
        path = '/open/api/v2/market/ticker'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
        }
        return self._request(method, path, params)

    def get_depth(self, symbol, depth):
        """get market depth"""
        method = 'GET'
        path = '/open/api/v2/market/depth'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'depth': depth,
        }
        return self._request(method, path, params)

    def get_deals(self, symbol, limit):
        """get deals records"""
        method = 'GET'
        path = '/open/api/v2/market/deals'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'limit': limit,
        }
        return self._request(method, path, params)

    def get_kline(self, symbol, interval):
        """k-line data"""
        method = 'GET'
        path = '/open/api/v2/market/kline'
        params = {
            'api_key': self.API_KEY,
            'symbol': symbol,
            'interval': interval,
        }
        return self._request(method, path, params)

    def get_account_info(self):
        """account information"""
        method = 'GET'
        path = '/open/api/v2/account/info'
        params = self._sign(method, path)
        return self._request(method, path, params)

    def _request_with_json(self, method, path, params, json):
        url = '{}{}'.format(type(self).ROOT_URL, path)
        with contextlib.closing(
            requests.request(method, url, params=params, json=json)
        ) as response:
            response_json = response.json()
            code = response_json.get('code', 0)
            if code != 200:
                raise Exception(
                    type(self).ERROR_MESSAGES.get(code, response_json.get('msg', '未知错误。'))
                )
            return response_json.get('data', {})

    def place_order(self, symbol, price, quantity, trade_type, order_type):
        """place order"""
        method = 'POST'
        path = '/open/api/v2/order/place'
        params = self._sign(method, path)
        data = {
            'symbol': symbol,
            'price': price,
            'quantity': quantity,
            'trade_type': trade_type,
            'order_type': order_type,
        }
        return self._request_with_json(method, path, params, data)

    def batch_orders(self, orders):
        """batch order"""
        method = 'POST'
        path = '/open/api/v2/order/place_batch'
        params = self._sign(method, path)
        return self._request_with_json(method, path, params, orders)

    def cancel_order(self, order_id):
        """cancel in batch"""
        method = 'DELETE'
        path = '/open/api/v2/order/cancel'

        origin_trade_no = order_id
        if isinstance(order_id, list):
            origin_trade_no = parse.quote(','.join(order_id))
        params = self._sign(method, path, original_params={'order_ids': origin_trade_no})
        if isinstance(order_id, list):
            params['order_ids'] = ','.join(order_id)

        return self._request(method, path, params)

    def get_open_orders(self, symbol):
        """current orders"""
        method = 'GET'
        path = '/open/api/v2/order/open_orders'

        original_params = {
            'symbol': symbol,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def get_all_orders(self, symbol, trade_type):
        """order list"""
        method = 'GET'
        path = '/open/api/v2/order/list'

        original_params = {
            'symbol': symbol,
            'trade_type': trade_type,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def query_order(self, order_id):
        """query order"""
        method = 'GET'
        path = '/open/api/v2/order/query'

        origin_trade_no = order_id
        if isinstance(order_id, list):
            origin_trade_no = parse.quote(','.join(order_id))
        original_params = {
            'order_ids': origin_trade_no,
        }
        params = self._sign(method, path, original_params=original_params)
        if isinstance(order_id, list):
            params['order_ids'] = ','.join(order_id)

        return self._request(method, path, params)

    def get_deal_orders(self, symbol):
        """account deal records"""
        method = 'GET'
        path = '/open/api/v2/order/deals'

        original_params = {
            'symbol': symbol,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

    def get_deal_detail(self, order_id):
        """deal detail"""
        method = 'GET'
        path = '/open/api/v2/order/deal_detail'

        original_params = {
            'order_id': order_id,
        }
        params = self._sign(method, path, original_params=original_params)

        return self._request(method, path, params)

# Cell
import base64
import copy
from decimal import Decimal
import os
import yaml


class Status(object):

    PATH = os.getenv('ROBOT_PATH') or '.'
    STATUS_FILE = f'{PATH}/robot-status'
    TMPFILE = f'{PATH}/_tmp'

    robot_name_prefix = ''

    def __init__(self, robot_name, crypto_symbol, fiat_symbol, trade_unit, max_used_fiat_money_limit=Decimal('Infinity')):
        self.robot_name = robot_name
        self.crypto_symbol, self.fiat_symbol = crypto_symbol, fiat_symbol
        self.trade_unit = trade_unit

        self.max_used_fiat_money_limit = max_used_fiat_money_limit
        self.unused_fiat_money = None

        self.now_buy_fiat_price = Decimal('Infinity')
        self.now_sell_fiat_price = 0

        self.now_buy_fiat_price_without_fee = Decimal('Infinity')
        self.now_sell_fiat_price_without_fee = 0

        self.sample_number = 0
        self.trade_count = 0

        self.buy_count = 0
        self.clear_bought_status()

        self.sell_count = 0
        self.clear_sold_status()

        self.last_transaction = None
        self.total_gained_fiat_money = 0

    def get_max_used_fiat_money(self, new_unused_fiat_money=None):
        if isinstance(new_unused_fiat_money, Decimal):
            self.unused_fiat_money = new_unused_fiat_money
        max_used_fiat_money = self.unused_fiat_money + self.used_fiat_money
#         max_used_fiat_money = self.unused_fiat_money + self.total_gained_fiat_money
        if max_used_fiat_money > self.max_used_fiat_money_limit:
            return self.max_used_fiat_money_limit
        return max_used_fiat_money

    def get_usage(self, new_unused_fiat_money=None):
        max_used_fiat_money = self.get_max_used_fiat_money(new_unused_fiat_money)
        if max_used_fiat_money == 0:
            return 0
        return self.used_fiat_money / max_used_fiat_money

    def get_robot_title(self):
        robot_status_description = f'{self.get_usage() * 100:.2f}% / {self.get_gain_fiat_money_percentage() * 100:+.2f}%'
        if self.bought_average_fiat_price is not None:
            robot_status_description = f'{self.bought_average_fiat_price:.8f} / {robot_status_description}'
        return f'{self.robot_name} ({robot_status_description}) at {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}'

    def fiat_price_is_lower_than_average(self):
        return self.bought_average_fiat_price is not None and self.now_buy_fiat_price < self.bought_average_fiat_price

    def fiat_price_is_higher_than_average(self):
        return self.bought_average_fiat_price is not None and self.now_sell_fiat_price > self.bought_average_fiat_price

    def get_gain_fiat_money(self):
        self.gain_fiat_money = self.now_sell_fiat_price * self.bought_amount - self.used_fiat_money
        return self.now_sell_fiat_price * self.bought_amount - self.used_fiat_money

    # TODO: time measurement, binance-like cumulative profit curve
    def get_gain_fiat_money_percentage(self):
        if self.used_fiat_money > 0:
            return self.get_gain_fiat_money() / self.used_fiat_money
        return 0

    def get_total_gain_fiat_money(self):
        return self.total_gained_fiat_money + self.get_gain_fiat_money()

    def __str__(self):
        sell_fiat_price_description = f'{self.now_sell_fiat_price:.8f}'
        if self.bought_average_fiat_price is not None:
            diff_fiat_price = self.now_sell_fiat_price - self.bought_average_fiat_price
            sell_fiat_price_description = f'{diff_fiat_price:.8f} = {self.now_sell_fiat_price:.8f} - {self.bought_average_fiat_price:.8f}'
        return (
            f'GAIN {self.get_total_gain_fiat_money():+.4f} = {self.total_gained_fiat_money:+.4f} {self.get_gain_fiat_money():+.4f} ({self.get_gain_fiat_money_percentage() * 100:+.2f}%) {self.fiat_symbol} in total by {self.get_robot_title()} after\n'
            f'SELL {self.bought_amount:.4f} {self.crypto_symbol} for {sell_fiat_price_description} {self.fiat_symbol}/{self.crypto_symbol}. BUY for {self.now_buy_fiat_price:.8f} {self.fiat_symbol}/{self.crypto_symbol}.\n'
        )

    def get_max_sold_unit_amount(self):
        return self.bought_unit_amount + self.sold_unit_amount

    def estimate_gained_fiat_money(self, sell_unit_amount, sell_fiat_price=None):
        if sell_unit_amount < 0:
            raise Exception('Status::estimate_gained_fiat_money  sell_unit_amount < 0')
        if self.bought_average_fiat_price is None:
            return None
        if sell_fiat_price is None:
            sell_fiat_price = self.now_sell_fiat_price
        return (sell_fiat_price - self.bought_average_fiat_price) * (self.trade_unit * sell_unit_amount)

    @classmethod
    def get_status_file(cls):
        return f'{cls.STATUS_FILE}.yaml'

    def get_file_name_suffix(self):
        return f'{type(self).robot_name_prefix}{base64.b64encode(self.robot_name.encode("ascii")).decode("ascii")}'

    def get_unique_status_file(self):
        return f'{type(self).STATUS_FILE}-{self.get_file_name_suffix()}.yaml'

    def read(self):
        status_file = self.get_unique_status_file()
        if not os.path.exists(status_file):
            return self
        with open(status_file, 'r') as f:
            self.__dict__.update(
                yaml.load(f, Loader=yaml.FullLoader)
            )
        for i in self.__dict__:
            if isinstance(self.__dict__[i], float):
                self.__dict__[i] = Decimal(repr(self.__dict__[i]))
        return self

    def write(self):
        this = copy.deepcopy(self)
        for i in this.__dict__:
            if isinstance(this.__dict__[i], Decimal):
                this.__dict__[i] = float(this.__dict__[i])
        tmp_file_name = f'{type(this).TMPFILE}-{self.get_file_name_suffix()}'
        with open(tmp_file_name, 'w') as f:
            yaml.dump(this.__dict__, f, sort_keys=False)
        os.replace(tmp_file_name, this.get_unique_status_file())

    def clear_bought_status(self):
        self.bought_unit_amount = 0
        self.used_fiat_money = 0
        self.bought_amount = 0
        self.bought_average_fiat_price = None

    def clear_sold_status(self):
        self.sold_unit_amount = 0
        self.got_fiat_money = 0
        self.sold_amount = 0
        self.sold_average_fiat_price = None

    def trim_bought_status(self):
        if self.bought_unit_amount > 0:
            self.bought_amount = self.trade_unit * self.bought_unit_amount
            self.bought_average_fiat_price = self.used_fiat_money / self.bought_amount
        else:
            self.clear_bought_status()

    def trim_sold_status(self):
        if self.sold_unit_amount > 0:
            self.sold_amount = self.trade_unit * self.sold_unit_amount
            self.sold_average_fiat_price = self.got_fiat_money / self.sold_amount
        else:
            self.clear_sold_status()

    def update_bought_status(self, **trade):
        buy_fiat_price = trade.get('fiat_price', self.now_buy_fiat_price)
        buy_unit_amount = trade.get('unit_amount', 0)
        self.bought_unit_amount += buy_unit_amount
        self.used_fiat_money += buy_fiat_price * (self.trade_unit * buy_unit_amount)
        self.trim_bought_status()

    def update_sold_status(self, **trade):
        sell_fiat_price = trade.get('fiat_price', self.now_sell_fiat_price)
        sell_unit_amount = trade.get('unit_amount', 0)
        self.sold_unit_amount += sell_unit_amount
        self.got_fiat_money += sell_fiat_price * (self.trade_unit * sell_unit_amount)
        self.trim_sold_status()

    def trim_trade_status(self):
        self.trim_bought_status()
        self.trim_sold_status()

    def update(self, status=None):
        if isinstance(status, type(self)):
            self.__dict__.update(status.__dict__)
        if isinstance(status, dict):
            self.__dict__.update(status)
        self.trim_trade_status()

# Cell
import os
import time
import yaml


class Fetcher(object):

    LIQUIDITY_YAML = './crypto-liquidity'
    TRADING_SPEC_YAML = './crypto-trading-spec'

    def __init__(self, exchange):
        self.mxc = MXCAPI(os.environ['MXC_ACCESS_KEY'], os.environ['MXC_SECRET_KEY'])
        self.exchange = exchange

    @staticmethod
    def write(yaml_data, yaml_file_path):
        with open(yaml_file_path, 'w') as f:
            yaml.dump(yaml_data, f, sort_keys=False)

    @staticmethod
    def read(yaml_file_path):
        if not os.path.exists(yaml_file_path):
            return {}
        with open(yaml_file_path) as f:
            return yaml.load(f, Loader=yaml.FullLoader)

    @staticmethod
    def extract_symbols(liquidity):
        symbol_and_liquid = liquidity.items()
        symbols = {
            symbol for symbol, _ in symbol_and_liquid
        }
        liquid_symbols = {
            symbol for symbol, liquid in symbol_and_liquid if liquid == True
        }
        return symbols, liquid_symbols

    def fetch_symbols(self):
        liquidity = {
            trading_spec['symbol']: trading_spec.get('limited', False) for trading_spec in self.mxc.get_symbols()
        }
        type(self).write(liquidity, f'{type(self).LIQUIDITY_YAML}-{type(self.exchange).__name__}.yaml')
        return type(self).extract_symbols(liquidity)

    def read_symbols(self):
        liquidity = type(self).read(f'{type(self).LIQUIDITY_YAML}-{type(self.exchange).__name__}.yaml')
        return type(self).extract_symbols(liquidity)

    def get_trading_spec(self, crypto_symbol, fiat_symbol):
        yaml_file_path = f'{type(self).TRADING_SPEC_YAML}-{type(self.exchange).__name__}.yaml'
        trading_spec = self.exchange.get_trading_specification(crypto_symbol, fiat_symbol)
        trading_specs = type(self).read(yaml_file_path)
        trading_specs.update({
            f'{crypto_symbol}-{fiat_symbol}': trading_spec
        })
        type(self).write(trading_specs, yaml_file_path)
        return trading_spec

# Cell
class Portfolio(object):
    def __init__(self, portfolio):
        if isinstance(portfolio, type(self)):
            self.__dict__.update(portfolio.__dict__)
        if isinstance(portfolio, dict):
            self.__dict__.update(portfolio)
        if isinstance(portfolio, list):
            self.__dict__.update(dict(portfolio))

# Cell
import copy
from datetime import datetime
from decimal import Decimal
import os


class BookKeeper(object):

    def __init__(self, exchange, status_list):
        self.exchange = exchange

        self.status_list = status_list
        self.portfolio = self.get_portfolio()
        for status in self.status_list:
            status.unused_fiat_money = getattr(self.portfolio, status.fiat_symbol)

        self.estimate_functions = {
            'buy': self.estimate_status_by_buying,
            'sell': self.estimate_status_by_selling
        }

    def __enter__(self):
        self.fsh = open('sample-history.txt', 'a', 1)
        self.fth = open('transaction-history.txt', 'a', 1)
#         self.fth_origin = open('transaction-history-origin.txt', 'a', 1)
        type(self).fth = open('transaction-exception.txt', 'a', 1)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.fsh.close()
        self.fth.close()
#         self.fth_origin.close()
        type(self).fth.close()
        if exc_type == Exception and str(exc_value) == MXCAPI.ERROR_MESSAGES[30020]:
            print(MXCAPI.ERROR_MESSAGES[30020])
            return True
        return False

    def get_portfolio(self):
        return Portfolio(self.exchange.get_portfolio())

    def estimate_status_list(self):
        old_portfolio = self.portfolio
        new_portfolio = self.get_portfolio()
        self.portfolio = new_portfolio

        new_status_list = []
        for status in self.status_list:
            new_status = type(self).estimate_status(status, old_portfolio, new_portfolio)
            new_status_list.append(new_status)
            if new_status is not status:
                self.fth.write(new_status.last_transaction)

        return new_status_list

    @classmethod
    def estimate_status(cls, status, old_portfolio, new_portfolio):
        old_fiat_money = getattr(old_portfolio, status.fiat_symbol)
        old_amount = getattr(old_portfolio, status.crypto_symbol, 0)
        new_fiat_money = getattr(new_portfolio, status.fiat_symbol)
        new_amount = getattr(new_portfolio, status.crypto_symbol, 0)

        if old_amount > new_amount and old_fiat_money < new_fiat_money:
            amount = old_amount - new_amount
            fiat_price = (new_fiat_money - old_fiat_money) / amount

            old_status_amount = status.bought_amount
            new_status = cls.estimate_status_by_selling(
                status = status,
                unit_amount = amount / status.trade_unit,
                fiat_price = fiat_price,
                buy_unit_amount = min(0, new_amount - old_status_amount) / status.trade_unit,
                new_unused_fiat_money = new_fiat_money
            )

            now_sell_fiat_price = status.now_sell_fiat_price
            if now_sell_fiat_price == Decimal('0'):
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status
            if abs(fiat_price - now_sell_fiat_price) / now_sell_fiat_price > Decimal(50/100):
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status

            return new_status

        if old_amount < new_amount and old_fiat_money > new_fiat_money:
            amount = new_amount - old_amount
            fiat_price = (old_fiat_money - new_fiat_money) / amount

            new_status = cls.estimate_status_by_buying(
                status = status,
                unit_amount = amount / status.trade_unit,
                fiat_price = fiat_price,
                new_unused_fiat_money = new_fiat_money
            )

            now_buy_fiat_price = status.now_buy_fiat_price
            if now_buy_fiat_price == Decimal('Infinity'):
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status
            if abs(fiat_price - now_buy_fiat_price) / now_buy_fiat_price > Decimal(50) / 100:
                cls.fth.write(f'{new_status.last_transaction}\n')
                status.unused_fiat_money = new_fiat_money
                return status

            return new_status

        if old_amount > new_amount and old_fiat_money >= new_fiat_money:
            amount = old_amount - new_amount
            old_status_amount = status.bought_amount
            return cls.estimate_status_by_utilizing(
                status = status,
                unit_amount = amount / status.trade_unit,
                buy_unit_amount = min(0, new_amount - old_status_amount) / status.trade_unit,
                new_unused_fiat_money = new_fiat_money
            )

        if old_amount < new_amount and old_fiat_money <= new_fiat_money:
            amount = new_amount - old_amount
            return cls.estimate_status_by_receiving(
                status = status,
                unit_amount = amount / status.trade_unit,
                new_unused_fiat_money = new_fiat_money
            )

        status.unused_fiat_money = new_fiat_money
        return status

    @staticmethod
    def estimate_status_by_receiving(status, unit_amount, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_receiving: unit_amount <= 0')

        old_status = status
        new_status = copy.deepcopy(old_status)

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'RECEIVED {amount:.4f} = -{old_amount:.4f} ({old_percentage:.2f}%) +{new_amount:.4f} ({new_percentage:.2f}%) {amount:+.4f} {new_status.crypto_symbol}\n'
        )

        return new_status

    @staticmethod
    def estimate_status_by_utilizing(status, unit_amount, buy_unit_amount=None, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_utilizing: unit_amount <= 0')
        if buy_unit_amount is None:
            buy_unit_amount = -unit_amount

        old_status = status
        new_status = copy.deepcopy(old_status)

        if new_status.bought_average_fiat_price is not None:
            new_status.update_bought_status(fiat_price=new_status.bought_average_fiat_price, unit_amount=buy_unit_amount)

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'UTILIZED {amount:.4f} = +{old_amount:.4f} ({old_percentage:.2f}%) -{new_amount:.4f} ({new_percentage:.2f}%) {amount-(old_amount-new_amount):+.4f} {new_status.crypto_symbol}\n'
        )

        return new_status

    @staticmethod
    def estimate_status_by_buying(status, unit_amount, fiat_price=None, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_buying: unit_amount <= 0')
        if fiat_price is None:
            fiat_price = status.now_buy_fiat_price

        old_status = status
        new_status = copy.deepcopy(old_status)

        new_status.buy_count += 1
        new_status.update_bought_status(fiat_price=fiat_price, unit_amount=unit_amount)

        new_status.update(
            status = {
                'sold_unit_amount': 0
            }
        )

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'BOUGHT {amount:.4f} = -{old_amount:.4f} ({old_percentage:.2f}%) +{new_amount:.4f} ({new_percentage:.2f}%) {new_status.crypto_symbol} for {fiat_price:.8f} {new_status.fiat_symbol}/{new_status.crypto_symbol}:'
            f' NO.{new_status.trade_count + 1}-{new_status.buy_count} at {datetime.now()}\n'
        )

        return new_status

    @staticmethod
    def estimate_status_by_selling(status, unit_amount, fiat_price=None, buy_unit_amount=None, new_unused_fiat_money=None):
        if unit_amount <= 0:
            raise Exception('BookKeeper::estimate_status_by_selling: unit_amount <= 0')
        if fiat_price is None:
            fiat_price = status.now_sell_fiat_price
        if buy_unit_amount is None:
            buy_unit_amount = -unit_amount

        old_status = status
        new_status = copy.deepcopy(old_status)

        new_status.sell_count += 1
        if new_status.bought_average_fiat_price is not None:
            new_status.update_bought_status(fiat_price=new_status.bought_average_fiat_price, unit_amount=buy_unit_amount)
        new_status.update_sold_status(fiat_price=fiat_price, unit_amount=unit_amount)

        if new_status.bought_unit_amount == 0:
            new_status.update(
                status = {
                    'trade_count': new_status.trade_count + 1,
                    'buy_count': 0,
                    'sell_count': 0
                }
            )

        gained_fiat_money = old_status.estimate_gained_fiat_money(unit_amount, fiat_price)
        if gained_fiat_money is None:
            gained_fiat_money = 0
        new_status.total_gained_fiat_money += gained_fiat_money

        old_avg_price = old_status.bought_average_fiat_price
        if old_avg_price is None:
            old_avg_price = 0
        diff_price = fiat_price - old_avg_price

        amount = status.trade_unit * unit_amount

        old_amount = old_status.bought_amount
        old_percentage = old_status.get_usage() * 100
        new_amount = new_status.bought_amount
        new_percentage = new_status.get_usage(new_unused_fiat_money) * 100

        new_status.last_transaction = (
            f'GAINED {gained_fiat_money:+.4f} {new_status.fiat_symbol}: GAINED {new_status.total_gained_fiat_money:+.4f} {new_status.fiat_symbol} in total at {datetime.now()} after\n'
            f'SOLD {amount:.4f} = +{old_amount:.4f} ({old_percentage:.2f}%) -{new_amount:.4f} ({new_percentage:.2f}%) {amount-(old_amount-new_amount):+.4f} {new_status.crypto_symbol}'
            f' for {diff_price:.8f} = {fiat_price:.8f} - {old_avg_price:.8f} {new_status.fiat_symbol}/{new_status.crypto_symbol}: NO.{new_status.trade_count + 1}-{new_status.sell_count}\n'
        )

        return new_status

# Cell
import math
from decimal import Decimal
from scipy import optimize as opt
from numpy.lib import scimath
import time


class Trader(object):

    TRADE_RATE = Decimal('Infinity')

    SAMPLE_INTERVAL = 60
    HAPPY_COOLING_INTERVAL = 30
    SAD_COOLING_INTERVAL = 60 * 6

    LOSSABLE_UNIT_CC_SELL_JPY = Decimal('Infinity')

    MAX_GAIN_JPY = Decimal('Infinity') # useless
    MAX_LOSS_JPY = Decimal('Infinity') # useless
    MAX_LOST_JPY = Decimal('Infinity')

    def __init__(self, exchange, status, gainable_unit_cc_sold_ratio, lossable_unit_cc_bought_ratio, min_trade_fiat_price, max_trade_fiat_price):
        self.exchange = exchange

        self.status = status

        self.gainable_unit_cc_sold_ratio = gainable_unit_cc_sold_ratio # TODO: calculate from sample variance
        self.lossable_unit_cc_bought_ratio = lossable_unit_cc_bought_ratio

        self.min_unit_cc_trade_fiat_money = min_trade_fiat_price
        self.max_unit_cc_trade_fiat_money = max_trade_fiat_price

    def get_price(self):
        return self.exchange.get_price(self.status.crypto_symbol, self.status.fiat_symbol)

    def buy(self, unit_amount):
        if unit_amount <= 0:
            raise Exception('Trader::buy  unit_amount <= 0')
        amount = self.status.trade_unit * unit_amount
        self.exchange.buy(self.status.crypto_symbol, self.status.fiat_symbol, amount, self.status.now_buy_fiat_price_without_fee)

#         old_status = self.status
#         new_status = copy.deepcopy(old_status)

#         new_status.buy_count += 1
#         new_status.update_bought_status(fiat_price=fiat_price, unit_amount=unit_amount)

#         old_amount = old_status.bought_amount
#         old_percentage = old_status.get_usage() * 100
#         new_amount = new_status.bought_amount
#         new_percentage = new_status.get_usage(getattr(self.portfolio, self.status.fiat_symbol)) * 100

#         bookkeeper.fth_origin.write(
#             f'BOUGHT {amount:.4f} = -{old_amount:.4f} ({old_percentage:.2f}%) +{new_amount:.4f} ({new_percentage:.2f}%) CELO for {fiat_price:.4f} USDT/CELO:'
#             f' NO.{new_status.trade_count + 1}-{new_status.buy_count} at {datetime.now()}\n\n'
#         )

    def sell(self, unit_amount):
        if unit_amount <= 0:
            raise Exception('Trader::sell  unit_amount <= 0')
        amount = self.status.trade_unit * unit_amount
        self.exchange.sell(self.status.crypto_symbol, self.status.fiat_symbol, amount, self.status.now_sell_fiat_price_without_fee)

#         old_status = self.status
#         new_status = copy.deepcopy(old_status)

#         new_status.sell_count += 1
#         new_status.update_bought_status(fiat_price=new_status.bought_average_fiat_price, unit_amount=-unit_amount)
#         new_status.update_sold_status(fiat_price=fiat_price, unit_amount=unit_amount)

#         old_avg_price = old_status.bought_average_fiat_price
#         diff_price = fiat_price - old_avg_price
#         gained_fiat_money = old_status.estimate_gained_fiat_money(unit_amount, fiat_price)
#         new_status.total_gained_fiat_money += gained_fiat_money

#         old_amount = old_status.bought_amount
#         old_percentage = old_status.get_usage() * 100
#         new_amount = new_status.bought_amount
#         new_percentage = new_status.get_usage(getattr(self.portfolio, self.status.fiat_symbol)) * 100

#         bookkeeper.fth_origin.write(
#             f'GAINED {gained_fiat_money:+.4f} USDT: GAINED {new_status.total_gained_fiat_money:+.4f} USDT in total at {datetime.now()}\n'
#             f'SOLD {amount:.4f} = +{old_amount:.4f} ({old_percentage:.2f}%) -{new_amount:.4f} ({new_percentage:.2f}%) CELO'
#             f' for {diff_price:.4f} = {fiat_price:.4f} - {old_avg_price:.4f} USDT/CELO: NO.{new_status.trade_count + 1}-{new_status.sell_count}\n\n'
#         )

    def has_buyable_fiat_price(self):
        return self.status.now_buy_fiat_price > self.min_unit_cc_trade_fiat_money and self.status.now_buy_fiat_price < self.max_unit_cc_trade_fiat_money

    def get_buy_unit_amount(self):
        status = self.status

        used_fiat_money = float(status.used_fiat_money)
        unit_cc_diff_jpy = float(abs(status.bought_average_fiat_price - status.now_buy_fiat_price))

        lossable_unit_cc_bought_jpy = (status.bought_average_fiat_price - self.min_unit_cc_trade_fiat_money) * self.lossable_unit_cc_bought_ratio
        status.min_bought_average_fiat_price = status.bought_average_fiat_price - lossable_unit_cc_bought_jpy

        if status.used_fiat_money >= status.get_max_used_fiat_money():
            status.max_next_buy_fiat_price = Decimal('-Infinity')
            return 0

        # Minimum Action Price Difference
        min_unit_cc_diff_jpy = float(lossable_unit_cc_bought_jpy) / scimath.log(float(status.get_max_used_fiat_money() / status.used_fiat_money))
        status.max_next_buy_fiat_price = status.bought_average_fiat_price - Decimal(repr(min_unit_cc_diff_jpy)) * status.now_buy_fiat_price / status.bought_average_fiat_price

        bought_average_fiat_price = float(status.bought_average_fiat_price)
        now_buy_fiat_price = float(status.now_buy_fiat_price)
        trade_unit = float(status.trade_unit)

        return math.ceil(
            used_fiat_money * opt.fsolve(
                lambda c: [
                    (
                        unit_cc_diff_jpy - min_unit_cc_diff_jpy * scimath.log(1 + c[0]) * (bought_average_fiat_price * c[0] + now_buy_fiat_price) / (bought_average_fiat_price * c[0])
                    ).real
                ],
                [-0.5]
            )[0] / now_buy_fiat_price / trade_unit
        )

    def get_sell_unit_amount(self):
        status = self.status

        if status.bought_average_fiat_price is None:
            return 0

        sold_unit_amount = float(status.sold_unit_amount)
        unit_cc_diff_jpy = float(abs(status.now_sell_fiat_price - status.sold_average_fiat_price))

        status.max_sold_average_fiat_price = status.bought_average_fiat_price * (1 + self.gainable_unit_cc_sold_ratio)

        if status.sold_unit_amount >= status.get_max_sold_unit_amount():
            status.min_next_sell_fiat_price = Decimal('Infinity')
            return 0

        min_unit_cc_diff_jpy = float(status.max_sold_average_fiat_price - status.sold_average_fiat_price) / scimath.log(float(status.get_max_sold_unit_amount() / status.sold_unit_amount))
        status.min_next_sell_fiat_price = status.sold_average_fiat_price + Decimal(repr(min_unit_cc_diff_jpy))

        c = opt.fsolve(
            lambda c: [
                (
                    unit_cc_diff_jpy - min_unit_cc_diff_jpy * scimath.log(1 + c[0]) * (c[0] + 1) / c[0]
                ).real
            ],
            [-0.5]
        )[0]

        if c < -1:
            return math.floor(status.bought_unit_amount)

        if c < 0:
            return 0

        return math.ceil(sold_unit_amount * c)

    def check_and_trade(self):
        status = self.status

        min_trade_fiat_money_limit = self.exchange.get_trading_specification(
            status.crypto_symbol, status.fiat_symbol
        ).get('min_trade_fiat_money_limit', 200)

        status.update(self.get_price())

        please_sell_unit_amount = 0

        if (status.sample_number % type(self).TRADE_RATE == 0 or status.sold_unit_amount == 0) and status.fiat_price_is_higher_than_average():
            please_sell_unit_amount = min(
                math.ceil(min_trade_fiat_money_limit / status.now_sell_fiat_price_without_fee / status.trade_unit),
                math.floor(status.bought_unit_amount)
            )
            cooling_interval = type(self).HAPPY_COOLING_INTERVAL

        if status.sold_unit_amount > 0 and status.now_sell_fiat_price > status.sold_average_fiat_price:
            trade_unit_amount = min(self.get_sell_unit_amount(), math.floor(status.bought_unit_amount))
            if trade_unit_amount > 0:
                please_sell_unit_amount = trade_unit_amount
                cooling_interval = type(self).HAPPY_COOLING_INTERVAL

        gained_fiat_money = status.estimate_gained_fiat_money(status.bought_unit_amount)
        if gained_fiat_money is not None and gained_fiat_money > type(self).MAX_GAIN_JPY:
            please_sell_unit_amount = math.floor(status.bought_unit_amount)
            cooling_interval = type(self).HAPPY_COOLING_INTERVAL

        if gained_fiat_money is not None and gained_fiat_money < -type(self).MAX_LOSS_JPY:
            please_sell_unit_amount = math.floor(status.bought_unit_amount)
            cooling_interval = type(self).SAD_COOLING_INTERVAL

        if status.bought_average_fiat_price is not None and status.now_sell_fiat_price < status.bought_average_fiat_price - type(self).LOSSABLE_UNIT_CC_SELL_JPY and status.get_usage() > 90/100:
            please_sell_unit_amount = math.floor(status.bought_unit_amount)
            cooling_interval = type(self).SAD_COOLING_INTERVAL

#         if status.bought_unit_amount > 0 and status.now_sell_fiat_price < self.min_unit_cc_trade_fiat_money:
#             please_sell_unit_amount = status.bought_unit_amount
#             cooling_interval = type(self).SAD_COOLING_INTERVAL

        if self.exchange.trade_fiat_money_is_larger_than_limit(
            status.crypto_symbol,
            status.fiat_symbol,
            status.trade_unit * please_sell_unit_amount,
            status.now_sell_fiat_price_without_fee
        ):
            self.sell(please_sell_unit_amount)
            status.sample_number = 0
            return cooling_interval, 'sell', please_sell_unit_amount

        please_buy_unit_amount = 0

        # TODO: self-adaptive by trend analysis
        # init_buy_jpy = status.get_max_used_fiat_money() / Decimal(math.exp(self.lossable_unit_cc_bought_ratio / (1 - self.lossable_unit_cc_bought_ratio)))
        init_buy_jpy = min_trade_fiat_money_limit * 5
        status.init_buy_jpy = init_buy_jpy
        # self.exchange.has_enough_unused_fiat_money(init_buy_jpy, status.unused_fiat_money) !! status.unused_fiat_money !! what if set max_used_fiat_money_limit to 0
        if status.used_fiat_money < min_trade_fiat_money_limit and self.exchange.has_enough_unused_fiat_money(init_buy_jpy, status.unused_fiat_money) and self.has_buyable_fiat_price():
            buy_fiat_money = max(init_buy_jpy - status.used_fiat_money, min_trade_fiat_money_limit)
            please_buy_unit_amount = math.ceil(buy_fiat_money / status.now_buy_fiat_price / status.trade_unit)

        if status.used_fiat_money < init_buy_jpy and status.fiat_price_is_lower_than_average() and self.exchange.has_enough_unused_fiat_money(init_buy_jpy - status.used_fiat_money, status.unused_fiat_money) and self.has_buyable_fiat_price():
            buy_fiat_money = max(init_buy_jpy - status.used_fiat_money, min_trade_fiat_money_limit)
            please_buy_unit_amount = math.ceil(buy_fiat_money / status.now_buy_fiat_price / status.trade_unit)

        if status.used_fiat_money >= init_buy_jpy and status.fiat_price_is_lower_than_average():
            trade_unit_amount = self.get_buy_unit_amount()
            while trade_unit_amount > 0 and not self.exchange.has_enough_unused_fiat_money(status.now_buy_fiat_price * status.trade_unit * trade_unit_amount, status.unused_fiat_money):
                trade_unit_amount >>= 1
            if trade_unit_amount > 0:
                please_buy_unit_amount = trade_unit_amount

        # print(f'{status.crypto_symbol}-{status.fiat_symbol}: please_buy_fiat_money={status.now_buy_fiat_price_without_fee * status.trade_unit * please_buy_unit_amount}\n')
        if self.exchange.trade_fiat_money_is_larger_than_limit(
            status.crypto_symbol,
            status.fiat_symbol,
            status.trade_unit * please_buy_unit_amount,
            status.now_buy_fiat_price_without_fee
        ):
            self.buy(please_buy_unit_amount)
            status.sample_number = 0
            return type(self).SAMPLE_INTERVAL, 'buy', please_buy_unit_amount

        return type(self).SAMPLE_INTERVAL, 'wait', 0

# Cell
import os
import requests


class Notifier(object):

    def __init__(self, channel_name='general', name='!!', icon_url='https://jupyter.org/assets/apple-touch-icon.png'):
        self.webhook_url = os.environ['SLACK_WEBHOOK_URL']

        self.good_channel_id = os.environ[f'SLACK_GOOD_{channel_name.upper()}_CHANNEL_ID']
        self.danger_channel_id = os.environ[f'SLACK_DANGER_{channel_name.upper()}_CHANNEL_ID']

        self.name = name
        self.icon_url = icon_url

    def send_slack(self, message, text, color='good'):
        if color == 'good':
            channel_id = self.good_channel_id
            message = f':grinning: {message}'
        if color == 'danger':
            channel_id = self.danger_channel_id
            message = f':slightly_frowning_face: {message}'

        requests.post(
            self.webhook_url,
            json={
                'channel': channel_id,
                'username': f'{self.name} Notifications',
                'icon_url': self.icon_url,
                'text': message,
                'mrkdwn': True,
                'attachments': [{
                    'title': '→ Trading Operations',
                    'title_link': 'https://jhub.name/user/sheng_wei/lab',
                    'text': text,
                    'color': color,
                }]
            }
        )